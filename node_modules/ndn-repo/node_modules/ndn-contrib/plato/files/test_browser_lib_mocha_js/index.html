<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/browser/lib/mocha.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/browser/lib/mocha.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">5840</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">222.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">56.37</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">;(function(){

// CommonJS require()

function require(p){
    var path = require.resolve(p)
      , mod = require.modules[path];
    if (!mod) throw new Error(&#039;failed to require &quot;&#039; + p + &#039;&quot;&#039;);
    if (!mod.exports) {
      mod.exports = {};
      mod.call(mod.exports, mod, mod.exports, require.relative(path));
    }
    return mod.exports;
  }

require.modules = {};

require.resolve = function (path){
    var orig = path
      , reg = path + &#039;.js&#039;
      , index = path + &#039;/index.js&#039;;
    return require.modules[reg] &amp;&amp; reg
      || require.modules[index] &amp;&amp; index
      || orig;
  };

require.register = function (path, fn){
    require.modules[path] = fn;
  };

require.relative = function (parent) {
    return function(p){
      if (&#039;.&#039; != p.charAt(0)) return require(p);

      var path = parent.split(&#039;/&#039;)
        , segs = p.split(&#039;/&#039;);
      path.pop();

      for (var i = 0; i &lt; segs.length; i++) {
        var seg = segs[i];
        if (&#039;..&#039; == seg) path.pop();
        else if (&#039;.&#039; != seg) path.push(seg);
      }

      return require(path.join(&#039;/&#039;));
    };
  };


require.register(&quot;browser/debug.js&quot;, function(module, exports, require){

module.exports = function(type){
  return function(){
  }
};

}); // module: browser/debug.js

require.register(&quot;browser/diff.js&quot;, function(module, exports, require){
/* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 *
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 *
 * JsDiff.diffCss: Diff targeted at CSS content
 *
 * These methods are based on the implementation proposed in
 * &quot;An O(ND) Difference Algorithm and its Variations&quot; (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */
var JsDiff = (function() {
  /*jshint maxparams: 5*/
  function clonePath(path) {
    return { newPos: path.newPos, components: path.components.slice(0) };
  }
  function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i &lt; array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&amp;/g, &#039;&amp;amp;&#039;);
    n = n.replace(/&lt;/g, &#039;&amp;lt;&#039;);
    n = n.replace(/&gt;/g, &#039;&amp;gt;&#039;);
    n = n.replace(/&quot;/g, &#039;&amp;quot;&#039;);

    return n;
  }

  var Diff = function(ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
  };
  Diff.prototype = {
      diff: function(oldString, newString) {
        // Handle the identity case (this is due to unrolling editLength == 0
        if (newString === oldString) {
          return [{ value: newString }];
        }
        if (!newString) {
          return [{ value: oldString, removed: true }];
        }
        if (!oldString) {
          return [{ value: newString, added: true }];
        }

        newString = this.tokenize(newString);
        oldString = this.tokenize(oldString);

        var newLen = newString.length, oldLen = oldString.length;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{ newPos: -1, components: [] }];

        // Seed editLength = 0
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos+1 &gt;= newLen &amp;&amp; oldPos+1 &gt;= oldLen) {
          return bestPath[0].components;
        }

        for (var editLength = 1; editLength &lt;= maxEditLength; editLength++) {
          for (var diagonalPath = -1*editLength; diagonalPath &lt;= editLength; diagonalPath+=2) {
            var basePath;
            var addPath = bestPath[diagonalPath-1],
                removePath = bestPath[diagonalPath+1];
            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath-1] = undefined;
            }

            var canAdd = addPath &amp;&amp; addPath.newPos+1 &lt; newLen;
            var canRemove = removePath &amp;&amp; 0 &lt;= oldPos &amp;&amp; oldPos &lt; oldLen;
            if (!canAdd &amp;&amp; !canRemove) {
              bestPath[diagonalPath] = undefined;
              continue;
            }

            // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph
            if (!canAdd || (canRemove &amp;&amp; addPath.newPos &lt; removePath.newPos)) {
              basePath = clonePath(removePath);
              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
            } else {
              basePath = clonePath(addPath);
              basePath.newPos++;
              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
            }

            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);

            if (basePath.newPos+1 &gt;= newLen &amp;&amp; oldPos+1 &gt;= oldLen) {
              return basePath.components;
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
        }
      },

      pushComponent: function(components, value, added, removed) {
        var last = components[components.length-1];
        if (last &amp;&amp; last.added === added &amp;&amp; last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length-1] =
            {value: this.join(last.value, value), added: added, removed: removed };
        } else {
          components.push({value: value, added: added, removed: removed });
        }
      },
      extractCommon: function(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath;
        while (newPos+1 &lt; newLen &amp;&amp; oldPos+1 &lt; oldLen &amp;&amp; this.equals(newString[newPos+1], oldString[oldPos+1])) {
          newPos++;
          oldPos++;

          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
        }
        basePath.newPos = newPos;
        return oldPos;
      },

      equals: function(left, right) {
        var reWhitespace = /\S/;
        if (this.ignoreWhitespace &amp;&amp; !reWhitespace.test(left) &amp;&amp; !reWhitespace.test(right)) {
          return true;
        } else {
          return left === right;
        }
      },
      join: function(left, right) {
        return left + right;
      },
      tokenize: function(value) {
        return value;
      }
  };

  var CharDiff = new Diff();

  var WordDiff = new Diff(true);
  var WordWithSpaceDiff = new Diff();
  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
    return removeEmpty(value.split(/(\s+|\b)/));
  };

  var CssDiff = new Diff(true);
  CssDiff.tokenize = function(value) {
    return removeEmpty(value.split(/([{}:;,]|\s+)/));
  };

  var LineDiff = new Diff();
  LineDiff.tokenize = function(value) {
    return value.split(/^/m);
  };

  return {
    Diff: Diff,

    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },
    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },
    diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },
    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },

    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },

    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
      var ret = [];

      ret.push(&#039;Index: &#039; + fileName);
      ret.push(&#039;===================================================================&#039;);
      ret.push(&#039;--- &#039; + fileName + (typeof oldHeader === &#039;undefined&#039; ? &#039;&#039; : &#039;\t&#039; + oldHeader));
      ret.push(&#039;+++ &#039; + fileName + (typeof newHeader === &#039;undefined&#039; ? &#039;&#039; : &#039;\t&#039; + newHeader));

      var diff = LineDiff.diff(oldStr, newStr);
      if (!diff[diff.length-1].value) {
        diff.pop();   // Remove trailing newline add
      }
      diff.push({value: &#039;&#039;, lines: []});   // Append an empty value to make cleanup easier

      function contextLines(lines) {
        return lines.map(function(entry) { return &#039; &#039; + entry; });
      }
      function eofNL(curRange, i, current) {
        var last = diff[diff.length-2],
            isLast = i === diff.length-2,
            isLastOfType = i === diff.length-3 &amp;&amp; (current.added !== last.added || current.removed !== last.removed);

        // Figure out if this is the last line for the given file and missing NL
        if (!/\n$/.test(current.value) &amp;&amp; (isLast || isLastOfType)) {
          curRange.push(&#039;\\ No newline at end of file&#039;);
        }
      }

      var oldRangeStart = 0, newRangeStart = 0, curRange = [],
          oldLine = 1, newLine = 1;
      for (var i = 0; i &lt; diff.length; i++) {
        var current = diff[i],
            lines = current.lines || current.value.replace(/\n$/, &#039;&#039;).split(&#039;\n&#039;);
        current.lines = lines;

        if (current.added || current.removed) {
          if (!oldRangeStart) {
            var prev = diff[i-1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;

            if (prev) {
              curRange = contextLines(prev.lines.slice(-4));
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?&#039;+&#039;:&#039;-&#039;) + entry; }));
          eofNL(curRange, i, current);

          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            // Close out any changes that have been output (or join overlapping)
            if (lines.length &lt;= 8 &amp;&amp; i &lt; diff.length-2) {
              // Overlapping
              curRange.push.apply(curRange, contextLines(lines));
            } else {
              // end the range and output
              var contextSize = Math.min(lines.length, 4);
              ret.push(
                  &#039;@@ -&#039; + oldRangeStart + &#039;,&#039; + (oldLine-oldRangeStart+contextSize)
                  + &#039; +&#039; + newRangeStart + &#039;,&#039; + (newLine-newRangeStart+contextSize)
                  + &#039; @@&#039;);
              ret.push.apply(ret, curRange);
              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
              if (lines.length &lt;= 4) {
                eofNL(ret, i, current);
              }

              oldRangeStart = 0;  newRangeStart = 0; curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      }

      return ret.join(&#039;\n&#039;) + &#039;\n&#039;;
    },

    applyPatch: function(oldStr, uniDiff) {
      var diffstr = uniDiff.split(&#039;\n&#039;);
      var diff = [];
      var remEOFNL = false,
          addEOFNL = false;

      for (var i = (diffstr[0][0]===&#039;I&#039;?4:0); i &lt; diffstr.length; i++) {
        if(diffstr[i][0] === &#039;@&#039;) {
          var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
          diff.unshift({
            start:meh[3],
            oldlength:meh[2],
            oldlines:[],
            newlength:meh[4],
            newlines:[]
          });
        } else if(diffstr[i][0] === &#039;+&#039;) {
          diff[0].newlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === &#039;-&#039;) {
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === &#039; &#039;) {
          diff[0].newlines.push(diffstr[i].substr(1));
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === &#039;\\&#039;) {
          if (diffstr[i-1][0] === &#039;+&#039;) {
            remEOFNL = true;
          } else if(diffstr[i-1][0] === &#039;-&#039;) {
            addEOFNL = true;
          }
        }
      }

      var str = oldStr.split(&#039;\n&#039;);
      for (var i = diff.length - 1; i &gt;= 0; i--) {
        var d = diff[i];
        for (var j = 0; j &lt; d.oldlength; j++) {
          if(str[d.start-1+j] !== d.oldlines[j]) {
            return false;
          }
        }
        Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));
      }

      if (remEOFNL) {
        while (!str[str.length-1]) {
          str.pop();
        }
      } else if (addEOFNL) {
        str.push(&#039;&#039;);
      }
      return str.join(&#039;\n&#039;);
    },

    convertChangesToXML: function(changes){
      var ret = [];
      for ( var i = 0; i &lt; changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push(&#039;&lt;ins&gt;&#039;);
        } else if (change.removed) {
          ret.push(&#039;&lt;del&gt;&#039;);
        }

        ret.push(escapeHTML(change.value));

        if (change.added) {
          ret.push(&#039;&lt;/ins&gt;&#039;);
        } else if (change.removed) {
          ret.push(&#039;&lt;/del&gt;&#039;);
        }
      }
      return ret.join(&#039;&#039;);
    },

    // See: http://code.google.com/p/google-diff-match-patch/wiki/API
    convertChangesToDMP: function(changes){
      var ret = [], change;
      for ( var i = 0; i &lt; changes.length; i++) {
        change = changes[i];
        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);
      }
      return ret;
    }
  };
})();

if (typeof module !== &#039;undefined&#039;) {
    module.exports = JsDiff;
}

}); // module: browser/diff.js

require.register(&quot;browser/events.js&quot;, function(module, exports, require){

/**
 * Module exports.
 */

exports.EventEmitter = EventEmitter;

/**
 * Check if `obj` is an array.
 */

function isArray(obj) {
  return &#039;[object Array]&#039; == {}.toString.call(obj);
}

/**
 * Event emitter constructor.
 *
 * @api public
 */

function EventEmitter(){};

/**
 * Adds a listener.
 *
 * @api public
 */

EventEmitter.prototype.on = function (name, fn) {
  if (!this.$events) {
    this.$events = {};
  }

  if (!this.$events[name]) {
    this.$events[name] = fn;
  } else if (isArray(this.$events[name])) {
    this.$events[name].push(fn);
  } else {
    this.$events[name] = [this.$events[name], fn];
  }

  return this;
};

EventEmitter.prototype.addListener = EventEmitter.prototype.on;

/**
 * Adds a volatile listener.
 *
 * @api public
 */

EventEmitter.prototype.once = function (name, fn) {
  var self = this;

  function on () {
    self.removeListener(name, on);
    fn.apply(this, arguments);
  };

  on.listener = fn;
  this.on(name, on);

  return this;
};

/**
 * Removes a listener.
 *
 * @api public
 */

EventEmitter.prototype.removeListener = function (name, fn) {
  if (this.$events &amp;&amp; this.$events[name]) {
    var list = this.$events[name];

    if (isArray(list)) {
      var pos = -1;

      for (var i = 0, l = list.length; i &lt; l; i++) {
        if (list[i] === fn || (list[i].listener &amp;&amp; list[i].listener === fn)) {
          pos = i;
          break;
        }
      }

      if (pos &lt; 0) {
        return this;
      }

      list.splice(pos, 1);

      if (!list.length) {
        delete this.$events[name];
      }
    } else if (list === fn || (list.listener &amp;&amp; list.listener === fn)) {
      delete this.$events[name];
    }
  }

  return this;
};

/**
 * Removes all listeners for an event.
 *
 * @api public
 */

EventEmitter.prototype.removeAllListeners = function (name) {
  if (name === undefined) {
    this.$events = {};
    return this;
  }

  if (this.$events &amp;&amp; this.$events[name]) {
    this.$events[name] = null;
  }

  return this;
};

/**
 * Gets all listeners for a certain event.
 *
 * @api public
 */

EventEmitter.prototype.listeners = function (name) {
  if (!this.$events) {
    this.$events = {};
  }

  if (!this.$events[name]) {
    this.$events[name] = [];
  }

  if (!isArray(this.$events[name])) {
    this.$events[name] = [this.$events[name]];
  }

  return this.$events[name];
};

/**
 * Emits an event.
 *
 * @api public
 */

EventEmitter.prototype.emit = function (name) {
  if (!this.$events) {
    return false;
  }

  var handler = this.$events[name];

  if (!handler) {
    return false;
  }

  var args = [].slice.call(arguments, 1);

  if (&#039;function&#039; == typeof handler) {
    handler.apply(this, args);
  } else if (isArray(handler)) {
    var listeners = handler.slice();

    for (var i = 0, l = listeners.length; i &lt; l; i++) {
      listeners[i].apply(this, args);
    }
  } else {
    return false;
  }

  return true;
};
}); // module: browser/events.js

require.register(&quot;browser/fs.js&quot;, function(module, exports, require){

}); // module: browser/fs.js

require.register(&quot;browser/path.js&quot;, function(module, exports, require){

}); // module: browser/path.js

require.register(&quot;browser/progress.js&quot;, function(module, exports, require){
/**
 * Expose `Progress`.
 */

module.exports = Progress;

/**
 * Initialize a new `Progress` indicator.
 */

function Progress() {
  this.percent = 0;
  this.size(0);
  this.fontSize(11);
  this.font(&#039;helvetica, arial, sans-serif&#039;);
}

/**
 * Set progress size to `n`.
 *
 * @param {Number} n
 * @return {Progress} for chaining
 * @api public
 */

Progress.prototype.size = function(n){
  this._size = n;
  return this;
};

/**
 * Set text to `str`.
 *
 * @param {String} str
 * @return {Progress} for chaining
 * @api public
 */

Progress.prototype.text = function(str){
  this._text = str;
  return this;
};

/**
 * Set font size to `n`.
 *
 * @param {Number} n
 * @return {Progress} for chaining
 * @api public
 */

Progress.prototype.fontSize = function(n){
  this._fontSize = n;
  return this;
};

/**
 * Set font `family`.
 *
 * @param {String} family
 * @return {Progress} for chaining
 */

Progress.prototype.font = function(family){
  this._font = family;
  return this;
};

/**
 * Update percentage to `n`.
 *
 * @param {Number} n
 * @return {Progress} for chaining
 */

Progress.prototype.update = function(n){
  this.percent = n;
  return this;
};

/**
 * Draw on `ctx`.
 *
 * @param {CanvasRenderingContext2d} ctx
 * @return {Progress} for chaining
 */

Progress.prototype.draw = function(ctx){
  try {
    var percent = Math.min(this.percent, 100)
      , size = this._size
      , half = size / 2
      , x = half
      , y = half
      , rad = half - 1
      , fontSize = this._fontSize;
  
    ctx.font = fontSize + &#039;px &#039; + this._font;
  
    var angle = Math.PI * 2 * (percent / 100);
    ctx.clearRect(0, 0, size, size);
  
    // outer circle
    ctx.strokeStyle = &#039;#9f9f9f&#039;;
    ctx.beginPath();
    ctx.arc(x, y, rad, 0, angle, false);
    ctx.stroke();
  
    // inner circle
    ctx.strokeStyle = &#039;#eee&#039;;
    ctx.beginPath();
    ctx.arc(x, y, rad - 1, 0, angle, true);
    ctx.stroke();
  
    // text
    var text = this._text || (percent | 0) + &#039;%&#039;
      , w = ctx.measureText(text).width;
  
    ctx.fillText(
        text
      , x - w / 2 + 1
      , y + fontSize / 2 - 1);
  } catch (ex) {} //don&#039;t fail if we can&#039;t render progress
  return this;
};

}); // module: browser/progress.js

require.register(&quot;browser/tty.js&quot;, function(module, exports, require){

exports.isatty = function(){
  return true;
};

exports.getWindowSize = function(){
  if (&#039;innerHeight&#039; in global) {
    return [global.innerHeight, global.innerWidth];
  } else {
    // In a Web Worker, the DOM Window is not available.
    return [640, 480];
  }
};

}); // module: browser/tty.js

require.register(&quot;context.js&quot;, function(module, exports, require){

/**
 * Expose `Context`.
 */

module.exports = Context;

/**
 * Initialize a new `Context`.
 *
 * @api private
 */

function Context(){}

/**
 * Set or get the context `Runnable` to `runnable`.
 *
 * @param {Runnable} runnable
 * @return {Context}
 * @api private
 */

Context.prototype.runnable = function(runnable){
  if (0 == arguments.length) return this._runnable;
  this.test = this._runnable = runnable;
  return this;
};

/**
 * Set test timeout `ms`.
 *
 * @param {Number} ms
 * @return {Context} self
 * @api private
 */

Context.prototype.timeout = function(ms){
  this.runnable().timeout(ms);
  return this;
};

/**
 * Set test slowness threshold `ms`.
 *
 * @param {Number} ms
 * @return {Context} self
 * @api private
 */

Context.prototype.slow = function(ms){
  this.runnable().slow(ms);
  return this;
};

/**
 * Inspect the context void of `._runnable`.
 *
 * @return {String}
 * @api private
 */

Context.prototype.inspect = function(){
  return JSON.stringify(this, function(key, val){
    if (&#039;_runnable&#039; == key) return;
    if (&#039;test&#039; == key) return;
    return val;
  }, 2);
};

}); // module: context.js

require.register(&quot;hook.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Runnable = require(&#039;./runnable&#039;);

/**
 * Expose `Hook`.
 */

module.exports = Hook;

/**
 * Initialize a new `Hook` with the given `title` and callback `fn`.
 *
 * @param {String} title
 * @param {Function} fn
 * @api private
 */

function Hook(title, fn) {
  Runnable.call(this, title, fn);
  this.type = &#039;hook&#039;;
}

/**
 * Inherit from `Runnable.prototype`.
 */

function F(){};
F.prototype = Runnable.prototype;
Hook.prototype = new F;
Hook.prototype.constructor = Hook;


/**
 * Get or set the test `err`.
 *
 * @param {Error} err
 * @return {Error}
 * @api public
 */

Hook.prototype.error = function(err){
  if (0 == arguments.length) {
    var err = this._error;
    this._error = null;
    return err;
  }

  this._error = err;
};

}); // module: hook.js

require.register(&quot;interfaces/bdd.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Suite = require(&#039;../suite&#039;)
  , Test = require(&#039;../test&#039;)
  , utils = require(&#039;../utils&#039;);

/**
 * BDD-style interface:
 *
 *      describe(&#039;Array&#039;, function(){
 *        describe(&#039;#indexOf()&#039;, function(){
 *          it(&#039;should return -1 when not present&#039;, function(){
 *
 *          });
 *
 *          it(&#039;should return the index when present&#039;, function(){
 *
 *          });
 *        });
 *      });
 *
 */

module.exports = function(suite){
  var suites = [suite];

  suite.on(&#039;pre-require&#039;, function(context, file, mocha){

    /**
     * Execute before running tests.
     */

    context.before = function(name, fn){
      suites[0].beforeAll(name, fn);
    };

    /**
     * Execute after running tests.
     */

    context.after = function(name, fn){
      suites[0].afterAll(name, fn);
    };

    /**
     * Execute before each test case.
     */

    context.beforeEach = function(name, fn){
      suites[0].beforeEach(name, fn);
    };

    /**
     * Execute after each test case.
     */

    context.afterEach = function(name, fn){
      suites[0].afterEach(name, fn);
    };

    /**
     * Describe a &quot;suite&quot; with the given `title`
     * and callback `fn` containing nested suites
     * and/or tests.
     */

    context.describe = context.context = function(title, fn){
      var suite = Suite.create(suites[0], title);
      suites.unshift(suite);
      fn.call(suite);
      suites.shift();
      return suite;
    };

    /**
     * Pending describe.
     */

    context.xdescribe =
    context.xcontext =
    context.describe.skip = function(title, fn){
      var suite = Suite.create(suites[0], title);
      suite.pending = true;
      suites.unshift(suite);
      fn.call(suite);
      suites.shift();
    };

    /**
     * Exclusive suite.
     */

    context.describe.only = function(title, fn){
      var suite = context.describe(title, fn);
      mocha.grep(suite.fullTitle());
      return suite;
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.it = context.specify = function(title, fn){
      var suite = suites[0];
      if (suite.pending) var fn = null;
      var test = new Test(title, fn);
      suite.addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.it.only = function(title, fn){
      var test = context.it(title, fn);
      var reString = &#039;^&#039; + utils.escapeRegexp(test.fullTitle()) + &#039;$&#039;;
      mocha.grep(new RegExp(reString));
      return test;
    };

    /**
     * Pending test case.
     */

    context.xit =
    context.xspecify =
    context.it.skip = function(title){
      context.it(title);
    };
  });
};

}); // module: interfaces/bdd.js

require.register(&quot;interfaces/exports.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Suite = require(&#039;../suite&#039;)
  , Test = require(&#039;../test&#039;);

/**
 * TDD-style interface:
 *
 *     exports.Array = {
 *       &#039;#indexOf()&#039;: {
 *         &#039;should return -1 when the value is not present&#039;: function(){
 *
 *         },
 *
 *         &#039;should return the correct index when the value is present&#039;: function(){
 *
 *         }
 *       }
 *     };
 *
 */

module.exports = function(suite){
  var suites = [suite];

  suite.on(&#039;require&#039;, visit);

  function visit(obj) {
    var suite;
    for (var key in obj) {
      if (&#039;function&#039; == typeof obj[key]) {
        var fn = obj[key];
        switch (key) {
          case &#039;before&#039;:
            suites[0].beforeAll(fn);
            break;
          case &#039;after&#039;:
            suites[0].afterAll(fn);
            break;
          case &#039;beforeEach&#039;:
            suites[0].beforeEach(fn);
            break;
          case &#039;afterEach&#039;:
            suites[0].afterEach(fn);
            break;
          default:
            suites[0].addTest(new Test(key, fn));
        }
      } else {
        var suite = Suite.create(suites[0], key);
        suites.unshift(suite);
        visit(obj[key]);
        suites.shift();
      }
    }
  }
};

}); // module: interfaces/exports.js

require.register(&quot;interfaces/index.js&quot;, function(module, exports, require){

exports.bdd = require(&#039;./bdd&#039;);
exports.tdd = require(&#039;./tdd&#039;);
exports.qunit = require(&#039;./qunit&#039;);
exports.exports = require(&#039;./exports&#039;);

}); // module: interfaces/index.js

require.register(&quot;interfaces/qunit.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Suite = require(&#039;../suite&#039;)
  , Test = require(&#039;../test&#039;)
  , utils = require(&#039;../utils&#039;);

/**
 * QUnit-style interface:
 *
 *     suite(&#039;Array&#039;);
 *
 *     test(&#039;#length&#039;, function(){
 *       var arr = [1,2,3];
 *       ok(arr.length == 3);
 *     });
 *
 *     test(&#039;#indexOf()&#039;, function(){
 *       var arr = [1,2,3];
 *       ok(arr.indexOf(1) == 0);
 *       ok(arr.indexOf(2) == 1);
 *       ok(arr.indexOf(3) == 2);
 *     });
 *
 *     suite(&#039;String&#039;);
 *
 *     test(&#039;#length&#039;, function(){
 *       ok(&#039;foo&#039;.length == 3);
 *     });
 *
 */

module.exports = function(suite){
  var suites = [suite];

  suite.on(&#039;pre-require&#039;, function(context, file, mocha){

    /**
     * Execute before running tests.
     */

    context.before = function(name, fn){
      suites[0].beforeAll(name, fn);
    };

    /**
     * Execute after running tests.
     */

    context.after = function(name, fn){
      suites[0].afterAll(name, fn);
    };

    /**
     * Execute before each test case.
     */

    context.beforeEach = function(name, fn){
      suites[0].beforeEach(name, fn);
    };

    /**
     * Execute after each test case.
     */

    context.afterEach = function(name, fn){
      suites[0].afterEach(name, fn);
    };

    /**
     * Describe a &quot;suite&quot; with the given `title`.
     */

    context.suite = function(title){
      if (suites.length &gt; 1) suites.shift();
      var suite = Suite.create(suites[0], title);
      suites.unshift(suite);
      return suite;
    };

    /**
     * Exclusive test-case.
     */

    context.suite.only = function(title, fn){
      var suite = context.suite(title, fn);
      mocha.grep(suite.fullTitle());
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.test = function(title, fn){
      var test = new Test(title, fn);
      suites[0].addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.test.only = function(title, fn){
      var test = context.test(title, fn);
      var reString = &#039;^&#039; + utils.escapeRegexp(test.fullTitle()) + &#039;$&#039;;
      mocha.grep(new RegExp(reString));
    };

    /**
     * Pending test case.
     */

    context.test.skip = function(title){
      context.test(title);
    };
  });
};

}); // module: interfaces/qunit.js

require.register(&quot;interfaces/tdd.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Suite = require(&#039;../suite&#039;)
  , Test = require(&#039;../test&#039;)
  , utils = require(&#039;../utils&#039;);;

/**
 * TDD-style interface:
 *
 *      suite(&#039;Array&#039;, function(){
 *        suite(&#039;#indexOf()&#039;, function(){
 *          suiteSetup(function(){
 *
 *          });
 *
 *          test(&#039;should return -1 when not present&#039;, function(){
 *
 *          });
 *
 *          test(&#039;should return the index when present&#039;, function(){
 *
 *          });
 *
 *          suiteTeardown(function(){
 *
 *          });
 *        });
 *      });
 *
 */

module.exports = function(suite){
  var suites = [suite];

  suite.on(&#039;pre-require&#039;, function(context, file, mocha){

    /**
     * Execute before each test case.
     */

    context.setup = function(name, fn){
      suites[0].beforeEach(name, fn);
    };

    /**
     * Execute after each test case.
     */

    context.teardown = function(name, fn){
      suites[0].afterEach(name, fn);
    };

    /**
     * Execute before the suite.
     */

    context.suiteSetup = function(name, fn){
      suites[0].beforeAll(name, fn);
    };

    /**
     * Execute after the suite.
     */

    context.suiteTeardown = function(name, fn){
      suites[0].afterAll(name, fn);
    };

    /**
     * Describe a &quot;suite&quot; with the given `title`
     * and callback `fn` containing nested suites
     * and/or tests.
     */

    context.suite = function(title, fn){
      var suite = Suite.create(suites[0], title);
      suites.unshift(suite);
      fn.call(suite);
      suites.shift();
      return suite;
    };

    /**
     * Pending suite.
     */
    context.suite.skip = function(title, fn) {
      var suite = Suite.create(suites[0], title);
      suite.pending = true;
      suites.unshift(suite);
      fn.call(suite);
      suites.shift();
    };

    /**
     * Exclusive test-case.
     */

    context.suite.only = function(title, fn){
      var suite = context.suite(title, fn);
      mocha.grep(suite.fullTitle());
    };

    /**
     * Describe a specification or test-case
     * with the given `title` and callback `fn`
     * acting as a thunk.
     */

    context.test = function(title, fn){
      var suite = suites[0];
      if (suite.pending) var fn = null;
      var test = new Test(title, fn);
      suite.addTest(test);
      return test;
    };

    /**
     * Exclusive test-case.
     */

    context.test.only = function(title, fn){
      var test = context.test(title, fn);
      var reString = &#039;^&#039; + utils.escapeRegexp(test.fullTitle()) + &#039;$&#039;;
      mocha.grep(new RegExp(reString));
    };

    /**
     * Pending test case.
     */

    context.test.skip = function(title){
      context.test(title);
    };
  });
};

}); // module: interfaces/tdd.js

require.register(&quot;mocha.js&quot;, function(module, exports, require){
/*!
 * mocha
 * Copyright(c) 2011 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var path = require(&#039;browser/path&#039;)
  , utils = require(&#039;./utils&#039;);

/**
 * Expose `Mocha`.
 */

exports = module.exports = Mocha;

/**
 * Expose internals.
 */

exports.utils = utils;
exports.interfaces = require(&#039;./interfaces&#039;);
exports.reporters = require(&#039;./reporters&#039;);
exports.Runnable = require(&#039;./runnable&#039;);
exports.Context = require(&#039;./context&#039;);
exports.Runner = require(&#039;./runner&#039;);
exports.Suite = require(&#039;./suite&#039;);
exports.Hook = require(&#039;./hook&#039;);
exports.Test = require(&#039;./test&#039;);

/**
 * Return image `name` path.
 *
 * @param {String} name
 * @return {String}
 * @api private
 */

function image(name) {
  return __dirname + &#039;/../images/&#039; + name + &#039;.png&#039;;
}

/**
 * Setup mocha with `options`.
 *
 * Options:
 *
 *   - `ui` name &quot;bdd&quot;, &quot;tdd&quot;, &quot;exports&quot; etc
 *   - `reporter` reporter instance, defaults to `mocha.reporters.Dot`
 *   - `globals` array of accepted globals
 *   - `timeout` timeout in milliseconds
 *   - `bail` bail on the first test failure
 *   - `slow` milliseconds to wait before considering a test slow
 *   - `ignoreLeaks` ignore global leaks
 *   - `grep` string or regexp to filter tests with
 *
 * @param {Object} options
 * @api public
 */

function Mocha(options) {
  options = options || {};
  this.files = [];
  this.options = options;
  this.grep(options.grep);
  this.suite = new exports.Suite(&#039;&#039;, new exports.Context);
  this.ui(options.ui);
  this.bail(options.bail);
  this.reporter(options.reporter);
  if (null != options.timeout) this.timeout(options.timeout);
  this.useColors(options.useColors)
  if (options.slow) this.slow(options.slow);

  this.suite.on(&#039;pre-require&#039;, function (context) {
    exports.afterEach = context.afterEach || context.teardown;
    exports.after = context.after || context.suiteTeardown;
    exports.beforeEach = context.beforeEach || context.setup;
    exports.before = context.before || context.suiteSetup;
    exports.describe = context.describe || context.suite;
    exports.it = context.it || context.test;
    exports.setup = context.setup || context.beforeEach;
    exports.suiteSetup = context.suiteSetup || context.before;
    exports.suiteTeardown = context.suiteTeardown || context.after;
    exports.suite = context.suite || context.describe;
    exports.teardown = context.teardown || context.afterEach;
    exports.test = context.test || context.it;
  });
}

/**
 * Enable or disable bailing on the first failure.
 *
 * @param {Boolean} [bail]
 * @api public
 */

Mocha.prototype.bail = function(bail){
  if (0 == arguments.length) bail = true;
  this.suite.bail(bail);
  return this;
};

/**
 * Add test `file`.
 *
 * @param {String} file
 * @api public
 */

Mocha.prototype.addFile = function(file){
  this.files.push(file);
  return this;
};

/**
 * Set reporter to `reporter`, defaults to &quot;dot&quot;.
 *
 * @param {String|Function} reporter name or constructor
 * @api public
 */

Mocha.prototype.reporter = function(reporter){
  if (&#039;function&#039; == typeof reporter) {
    this._reporter = reporter;
  } else {
    reporter = reporter || &#039;dot&#039;;
    var _reporter;
    try { _reporter = require(&#039;./reporters/&#039; + reporter); } catch (err) {};
    if (!_reporter) try { _reporter = require(reporter); } catch (err) {};
    if (!_reporter &amp;&amp; reporter === &#039;teamcity&#039;)
      console.warn(&#039;The Teamcity reporter was moved to a package named &#039; +
        &#039;mocha-teamcity-reporter &#039; +
        &#039;(https://npmjs.org/package/mocha-teamcity-reporter).&#039;);
    if (!_reporter) throw new Error(&#039;invalid reporter &quot;&#039; + reporter + &#039;&quot;&#039;);
    this._reporter = _reporter;
  }
  return this;
};

/**
 * Set test UI `name`, defaults to &quot;bdd&quot;.
 *
 * @param {String} bdd
 * @api public
 */

Mocha.prototype.ui = function(name){
  name = name || &#039;bdd&#039;;
  this._ui = exports.interfaces[name];
  if (!this._ui) try { this._ui = require(name); } catch (err) {};
  if (!this._ui) throw new Error(&#039;invalid interface &quot;&#039; + name + &#039;&quot;&#039;);
  this._ui = this._ui(this.suite);
  return this;
};

/**
 * Load registered files.
 *
 * @api private
 */

Mocha.prototype.loadFiles = function(fn){
  var self = this;
  var suite = this.suite;
  var pending = this.files.length;
  this.files.forEach(function(file){
    file = path.resolve(file);
    suite.emit(&#039;pre-require&#039;, global, file, self);
    suite.emit(&#039;require&#039;, require(file), file, self);
    suite.emit(&#039;post-require&#039;, global, file, self);
    --pending || (fn &amp;&amp; fn());
  });
};

/**
 * Enable growl support.
 *
 * @api private
 */

Mocha.prototype._growl = function(runner, reporter) {
  var notify = require(&#039;growl&#039;);

  runner.on(&#039;end&#039;, function(){
    var stats = reporter.stats;
    if (stats.failures) {
      var msg = stats.failures + &#039; of &#039; + runner.total + &#039; tests failed&#039;;
      notify(msg, { name: &#039;mocha&#039;, title: &#039;Failed&#039;, image: image(&#039;error&#039;) });
    } else {
      notify(stats.passes + &#039; tests passed in &#039; + stats.duration + &#039;ms&#039;, {
          name: &#039;mocha&#039;
        , title: &#039;Passed&#039;
        , image: image(&#039;ok&#039;)
      });
    }
  });
};

/**
 * Add regexp to grep, if `re` is a string it is escaped.
 *
 * @param {RegExp|String} re
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.grep = function(re){
  this.options.grep = &#039;string&#039; == typeof re
    ? new RegExp(utils.escapeRegexp(re))
    : re;
  return this;
};

/**
 * Invert `.grep()` matches.
 *
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.invert = function(){
  this.options.invert = true;
  return this;
};

/**
 * Ignore global leaks.
 *
 * @param {Boolean} ignore
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.ignoreLeaks = function(ignore){
  this.options.ignoreLeaks = !!ignore;
  return this;
};

/**
 * Enable global leak checking.
 *
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.checkLeaks = function(){
  this.options.ignoreLeaks = false;
  return this;
};

/**
 * Enable growl support.
 *
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.growl = function(){
  this.options.growl = true;
  return this;
};

/**
 * Ignore `globals` array or string.
 *
 * @param {Array|String} globals
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.globals = function(globals){
  this.options.globals = (this.options.globals || []).concat(globals);
  return this;
};

/**
 * Emit color output.
 *
 * @param {Boolean} colors
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.useColors = function(colors){
  this.options.useColors = arguments.length &amp;&amp; colors != undefined
    ? colors
    : true;
  return this;
};

/**
 * Use inline diffs rather than +/-.
 *
 * @param {Boolean} inlineDiffs
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.useInlineDiffs = function(inlineDiffs) {
  this.options.useInlineDiffs = arguments.length &amp;&amp; inlineDiffs != undefined
  ? inlineDiffs
  : false;
  return this;
};

/**
 * Set the timeout in milliseconds.
 *
 * @param {Number} timeout
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.timeout = function(timeout){
  this.suite.timeout(timeout);
  return this;
};

/**
 * Set slowness threshold in milliseconds.
 *
 * @param {Number} slow
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.slow = function(slow){
  this.suite.slow(slow);
  return this;
};

/**
 * Makes all tests async (accepting a callback)
 *
 * @return {Mocha}
 * @api public
 */

Mocha.prototype.asyncOnly = function(){
  this.options.asyncOnly = true;
  return this;
};

/**
 * Run tests and invoke `fn()` when complete.
 *
 * @param {Function} fn
 * @return {Runner}
 * @api public
 */

Mocha.prototype.run = function(fn){
  if (this.files.length) this.loadFiles();
  var suite = this.suite;
  var options = this.options;
  options.files = this.files;
  var runner = new exports.Runner(suite);
  var reporter = new this._reporter(runner, options);
  runner.ignoreLeaks = false !== options.ignoreLeaks;
  runner.asyncOnly = options.asyncOnly;
  if (options.grep) runner.grep(options.grep, options.invert);
  if (options.globals) runner.globals(options.globals);
  if (options.growl) this._growl(runner, reporter);
  exports.reporters.Base.useColors = options.useColors;
  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;
  return runner.run(fn);
};

}); // module: mocha.js

require.register(&quot;ms.js&quot;, function(module, exports, require){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if (&#039;string&#039; == typeof val) return parse(val);
  return options.long ? longFormat(val) : shortFormat(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || &#039;ms&#039;).toLowerCase();
  switch (type) {
    case &#039;years&#039;:
    case &#039;year&#039;:
    case &#039;y&#039;:
      return n * y;
    case &#039;days&#039;:
    case &#039;day&#039;:
    case &#039;d&#039;:
      return n * d;
    case &#039;hours&#039;:
    case &#039;hour&#039;:
    case &#039;h&#039;:
      return n * h;
    case &#039;minutes&#039;:
    case &#039;minute&#039;:
    case &#039;m&#039;:
      return n * m;
    case &#039;seconds&#039;:
    case &#039;second&#039;:
    case &#039;s&#039;:
      return n * s;
    case &#039;ms&#039;:
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function shortFormat(ms) {
  if (ms &gt;= d) return Math.round(ms / d) + &#039;d&#039;;
  if (ms &gt;= h) return Math.round(ms / h) + &#039;h&#039;;
  if (ms &gt;= m) return Math.round(ms / m) + &#039;m&#039;;
  if (ms &gt;= s) return Math.round(ms / s) + &#039;s&#039;;
  return ms + &#039;ms&#039;;
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function longFormat(ms) {
  return plural(ms, d, &#039;day&#039;)
    || plural(ms, h, &#039;hour&#039;)
    || plural(ms, m, &#039;minute&#039;)
    || plural(ms, s, &#039;second&#039;)
    || ms + &#039; ms&#039;;
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms &lt; n) return;
  if (ms &lt; n * 1.5) return Math.floor(ms / n) + &#039; &#039; + name;
  return Math.ceil(ms / n) + &#039; &#039; + name + &#039;s&#039;;
}

}); // module: ms.js

require.register(&quot;reporters/base.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var tty = require(&#039;browser/tty&#039;)
  , diff = require(&#039;browser/diff&#039;)
  , ms = require(&#039;../ms&#039;)
  , utils = require(&#039;../utils&#039;);

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval;

/**
 * Check if both stdio streams are associated with a tty.
 */

var isatty = tty.isatty(1) &amp;&amp; tty.isatty(2);

/**
 * Expose `Base`.
 */

exports = module.exports = Base;

/**
 * Enable coloring by default.
 */

exports.useColors = isatty || (process.env.MOCHA_COLORS !== undefined);

/**
 * Inline diffs instead of +/-
 */

exports.inlineDiffs = false;

/**
 * Default color map.
 */

exports.colors = {
    &#039;pass&#039;: 90
  , &#039;fail&#039;: 31
  , &#039;bright pass&#039;: 92
  , &#039;bright fail&#039;: 91
  , &#039;bright yellow&#039;: 93
  , &#039;pending&#039;: 36
  , &#039;suite&#039;: 0
  , &#039;error title&#039;: 0
  , &#039;error message&#039;: 31
  , &#039;error stack&#039;: 90
  , &#039;checkmark&#039;: 32
  , &#039;fast&#039;: 90
  , &#039;medium&#039;: 33
  , &#039;slow&#039;: 31
  , &#039;green&#039;: 32
  , &#039;light&#039;: 90
  , &#039;diff gutter&#039;: 90
  , &#039;diff added&#039;: 42
  , &#039;diff removed&#039;: 41
};

/**
 * Default symbol map.
 */

exports.symbols = {
  ok: &#039;&#039;,
  err: &#039;&#039;,
  dot: &#039;&#039;
};

// With node.js on Windows: use symbols available in terminal default fonts
if (&#039;win32&#039; == process.platform) {
  exports.symbols.ok = &#039;\u221A&#039;;
  exports.symbols.err = &#039;\u00D7&#039;;
  exports.symbols.dot = &#039;.&#039;;
}

/**
 * Color `str` with the given `type`,
 * allowing colors to be disabled,
 * as well as user-defined color
 * schemes.
 *
 * @param {String} type
 * @param {String} str
 * @return {String}
 * @api private
 */

var color = exports.color = function(type, str) {
  if (!exports.useColors) return str;
  return &#039;\u001b[&#039; + exports.colors[type] + &#039;m&#039; + str + &#039;\u001b[0m&#039;;
};

/**
 * Expose term window size, with some
 * defaults for when stderr is not a tty.
 */

exports.window = {
  width: isatty
    ? process.stdout.getWindowSize
      ? process.stdout.getWindowSize(1)[0]
      : tty.getWindowSize()[1]
    : 75
};

/**
 * Expose some basic cursor interactions
 * that are common among reporters.
 */

exports.cursor = {
  hide: function(){
    isatty &amp;&amp; process.stdout.write(&#039;\u001b[?25l&#039;);
  },

  show: function(){
    isatty &amp;&amp; process.stdout.write(&#039;\u001b[?25h&#039;);
  },

  deleteLine: function(){
    isatty &amp;&amp; process.stdout.write(&#039;\u001b[2K&#039;);
  },

  beginningOfLine: function(){
    isatty &amp;&amp; process.stdout.write(&#039;\u001b[0G&#039;);
  },

  CR: function(){
    if (isatty) {
      exports.cursor.deleteLine();
      exports.cursor.beginningOfLine();
    } else {
      process.stdout.write(&#039;\r&#039;);
    }
  }
};

/**
 * Outut the given `failures` as a list.
 *
 * @param {Array} failures
 * @api public
 */

exports.list = function(failures){
  console.error();
  failures.forEach(function(test, i){
    // format
    var fmt = color(&#039;error title&#039;, &#039;  %s) %s:\n&#039;)
      + color(&#039;error message&#039;, &#039;     %s&#039;)
      + color(&#039;error stack&#039;, &#039;\n%s\n&#039;);

    // msg
    var err = test.err
      , message = err.message || &#039;&#039;
      , stack = err.stack || message
      , index = stack.indexOf(message) + message.length
      , msg = stack.slice(0, index)
      , actual = err.actual
      , expected = err.expected
      , escape = true;

    // uncaught
    if (err.uncaught) {
      msg = &#039;Uncaught &#039; + msg;
    }

    // explicitly show diff
    if (err.showDiff &amp;&amp; sameType(actual, expected)) {
      escape = false;
      err.actual = actual = stringify(canonicalize(actual));
      err.expected = expected = stringify(canonicalize(expected));
    }

    // actual / expected diff
    if (&#039;string&#039; == typeof actual &amp;&amp; &#039;string&#039; == typeof expected) {
      fmt = color(&#039;error title&#039;, &#039;  %s) %s:\n%s&#039;) + color(&#039;error stack&#039;, &#039;\n%s\n&#039;);
      var match = message.match(/^([^:]+): expected/);
      msg = &#039;\n      &#039; + color(&#039;error message&#039;, match ? match[1] : msg);

      if (exports.inlineDiffs) {
        msg += inlineDiff(err, escape);
      } else {
        msg += unifiedDiff(err, escape);
      }
    }

    // indent stack trace without msg
    stack = stack.slice(index ? index + 1 : index)
      .replace(/^/gm, &#039;  &#039;);

    console.error(fmt, (i + 1), test.fullTitle(), msg, stack);
  });
};

/**
 * Initialize a new `Base` reporter.
 *
 * All other reporters generally
 * inherit from this reporter, providing
 * stats such as test duration, number
 * of tests passed / failed etc.
 *
 * @param {Runner} runner
 * @api public
 */

function Base(runner) {
  var self = this
    , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }
    , failures = this.failures = [];

  if (!runner) return;
  this.runner = runner;

  runner.stats = stats;

  runner.on(&#039;start&#039;, function(){
    stats.start = new Date;
  });

  runner.on(&#039;suite&#039;, function(suite){
    stats.suites = stats.suites || 0;
    suite.root || stats.suites++;
  });

  runner.on(&#039;test end&#039;, function(test){
    stats.tests = stats.tests || 0;
    stats.tests++;
  });

  runner.on(&#039;pass&#039;, function(test){
    stats.passes = stats.passes || 0;

    var medium = test.slow() / 2;
    test.speed = test.duration &gt; test.slow()
      ? &#039;slow&#039;
      : test.duration &gt; medium
        ? &#039;medium&#039;
        : &#039;fast&#039;;

    stats.passes++;
  });

  runner.on(&#039;fail&#039;, function(test, err){
    stats.failures = stats.failures || 0;
    stats.failures++;
    test.err = err;
    failures.push(test);
  });

  runner.on(&#039;end&#039;, function(){
    stats.end = new Date;
    stats.duration = new Date - stats.start;
  });

  runner.on(&#039;pending&#039;, function(){
    stats.pending++;
  });
}

/**
 * Output common epilogue used by many of
 * the bundled reporters.
 *
 * @api public
 */

Base.prototype.epilogue = function(){
  var stats = this.stats;
  var tests;
  var fmt;

  console.log();

  // passes
  fmt = color(&#039;bright pass&#039;, &#039; &#039;)
    + color(&#039;green&#039;, &#039; %d passing&#039;)
    + color(&#039;light&#039;, &#039; (%s)&#039;);

  console.log(fmt,
    stats.passes || 0,
    ms(stats.duration));

  // pending
  if (stats.pending) {
    fmt = color(&#039;pending&#039;, &#039; &#039;)
      + color(&#039;pending&#039;, &#039; %d pending&#039;);

    console.log(fmt, stats.pending);
  }

  // failures
  if (stats.failures) {
    fmt = color(&#039;fail&#039;, &#039;  %d failing&#039;);

    console.error(fmt,
      stats.failures);

    Base.list(this.failures);
    console.error();
  }

  console.log();
};

/**
 * Pad the given `str` to `len`.
 *
 * @param {String} str
 * @param {String} len
 * @return {String}
 * @api private
 */

function pad(str, len) {
  str = String(str);
  return Array(len - str.length + 1).join(&#039; &#039;) + str;
}


/**
 * Returns an inline diff between 2 strings with coloured ANSI output
 *
 * @param {Error} Error with actual/expected
 * @return {String} Diff
 * @api private
 */

function inlineDiff(err, escape) {
  var msg = errorDiff(err, &#039;WordsWithSpace&#039;, escape);

  // linenos
  var lines = msg.split(&#039;\n&#039;);
  if (lines.length &gt; 4) {
    var width = String(lines.length).length;
    msg = lines.map(function(str, i){
      return pad(++i, width) + &#039; |&#039; + &#039; &#039; + str;
    }).join(&#039;\n&#039;);
  }

  // legend
  msg = &#039;\n&#039;
    + color(&#039;diff removed&#039;, &#039;actual&#039;)
    + &#039; &#039;
    + color(&#039;diff added&#039;, &#039;expected&#039;)
    + &#039;\n\n&#039;
    + msg
    + &#039;\n&#039;;

  // indent
  msg = msg.replace(/^/gm, &#039;      &#039;);
  return msg;
}

/**
 * Returns a unified diff between 2 strings
 *
 * @param {Error} Error with actual/expected
 * @return {String} Diff
 * @api private
 */

function unifiedDiff(err, escape) {
  var indent = &#039;      &#039;;
  function cleanUp(line) {
    if (escape) {
      line = escapeInvisibles(line);
    }
    if (line[0] === &#039;+&#039;) return indent + colorLines(&#039;diff added&#039;, line);
    if (line[0] === &#039;-&#039;) return indent + colorLines(&#039;diff removed&#039;, line);
    if (line.match(/\@\@/)) return null;
    if (line.match(/\\ No newline/)) return null;
    else return indent + line;
  }
  function notBlank(line) {
    return line != null;
  }
  msg = diff.createPatch(&#039;string&#039;, err.actual, err.expected);
  var lines = msg.split(&#039;\n&#039;).splice(4);
  return &#039;\n      &#039;
         + colorLines(&#039;diff added&#039;,   &#039;+ expected&#039;) + &#039; &#039;
         + colorLines(&#039;diff removed&#039;, &#039;- actual&#039;)
         + &#039;\n\n&#039;
         + lines.map(cleanUp).filter(notBlank).join(&#039;\n&#039;);
}

/**
 * Return a character diff for `err`.
 *
 * @param {Error} err
 * @return {String}
 * @api private
 */

function errorDiff(err, type, escape) {
  var actual   = escape ? escapeInvisibles(err.actual)   : err.actual;
  var expected = escape ? escapeInvisibles(err.expected) : err.expected;
  return diff[&#039;diff&#039; + type](actual, expected).map(function(str){
    if (str.added) return colorLines(&#039;diff added&#039;, str.value);
    if (str.removed) return colorLines(&#039;diff removed&#039;, str.value);
    return str.value;
  }).join(&#039;&#039;);
}

/**
 * Returns a string with all invisible characters in plain text
 *
 * @param {String} line
 * @return {String}
 * @api private
 */
function escapeInvisibles(line) {
    return line.replace(/\t/g, &#039;&lt;tab&gt;&#039;)
               .replace(/\r/g, &#039;&lt;CR&gt;&#039;)
               .replace(/\n/g, &#039;&lt;LF&gt;\n&#039;);
}

/**
 * Color lines for `str`, using the color `name`.
 *
 * @param {String} name
 * @param {String} str
 * @return {String}
 * @api private
 */

function colorLines(name, str) {
  return str.split(&#039;\n&#039;).map(function(str){
    return color(name, str);
  }).join(&#039;\n&#039;);
}

/**
 * Stringify `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function stringify(obj) {
  if (obj instanceof RegExp) return obj.toString();
  return JSON.stringify(obj, null, 2);
}

/**
 * Return a new object that has the keys in sorted order.
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

 function canonicalize(obj, stack) {
   stack = stack || [];

   if (utils.indexOf(stack, obj) !== -1) return obj;

   var canonicalizedObj;

   if (&#039;[object Array]&#039; == {}.toString.call(obj)) {
     stack.push(obj);
     canonicalizedObj = utils.map(obj, function(item) {
       return canonicalize(item, stack);
     });
     stack.pop();
   } else if (typeof obj === &#039;object&#039; &amp;&amp; obj !== null) {
     stack.push(obj);
     canonicalizedObj = {};
     utils.forEach(utils.keys(obj).sort(), function(key) {
       canonicalizedObj[key] = canonicalize(obj[key], stack);
     });
     stack.pop();
   } else {
     canonicalizedObj = obj;
   }

   return canonicalizedObj;
 }

/**
 * Check that a / b have the same type.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Boolean}
 * @api private
 */

function sameType(a, b) {
  a = Object.prototype.toString.call(a);
  b = Object.prototype.toString.call(b);
  return a == b;
}


}); // module: reporters/base.js

require.register(&quot;reporters/doc.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , utils = require(&#039;../utils&#039;);

/**
 * Expose `Doc`.
 */

exports = module.exports = Doc;

/**
 * Initialize a new `Doc` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function Doc(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , total = runner.total
    , indents = 2;

  function indent() {
    return Array(indents).join(&#039;  &#039;);
  }

  runner.on(&#039;suite&#039;, function(suite){
    if (suite.root) return;
    ++indents;
    console.log(&#039;%s&lt;section class=&quot;suite&quot;&gt;&#039;, indent());
    ++indents;
    console.log(&#039;%s&lt;h1&gt;%s&lt;/h1&gt;&#039;, indent(), utils.escape(suite.title));
    console.log(&#039;%s&lt;dl&gt;&#039;, indent());
  });

  runner.on(&#039;suite end&#039;, function(suite){
    if (suite.root) return;
    console.log(&#039;%s&lt;/dl&gt;&#039;, indent());
    --indents;
    console.log(&#039;%s&lt;/section&gt;&#039;, indent());
    --indents;
  });

  runner.on(&#039;pass&#039;, function(test){
    console.log(&#039;%s  &lt;dt&gt;%s&lt;/dt&gt;&#039;, indent(), utils.escape(test.title));
    var code = utils.escape(utils.clean(test.fn.toString()));
    console.log(&#039;%s  &lt;dd&gt;&lt;pre&gt;&lt;code&gt;%s&lt;/code&gt;&lt;/pre&gt;&lt;/dd&gt;&#039;, indent(), code);
  });
}

}); // module: reporters/doc.js

require.register(&quot;reporters/dot.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , color = Base.color;

/**
 * Expose `Dot`.
 */

exports = module.exports = Dot;

/**
 * Initialize a new `Dot` matrix test reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function Dot(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , width = Base.window.width * .75 | 0
    , n = 0;

  runner.on(&#039;start&#039;, function(){
    process.stdout.write(&#039;\n  &#039;);
  });

  runner.on(&#039;pending&#039;, function(test){
    process.stdout.write(color(&#039;pending&#039;, Base.symbols.dot));
  });

  runner.on(&#039;pass&#039;, function(test){
    if (++n % width == 0) process.stdout.write(&#039;\n  &#039;);
    if (&#039;slow&#039; == test.speed) {
      process.stdout.write(color(&#039;bright yellow&#039;, Base.symbols.dot));
    } else {
      process.stdout.write(color(test.speed, Base.symbols.dot));
    }
  });

  runner.on(&#039;fail&#039;, function(test, err){
    if (++n % width == 0) process.stdout.write(&#039;\n  &#039;);
    process.stdout.write(color(&#039;fail&#039;, Base.symbols.dot));
  });

  runner.on(&#039;end&#039;, function(){
    console.log();
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
Dot.prototype = new F;
Dot.prototype.constructor = Dot;

}); // module: reporters/dot.js

require.register(&quot;reporters/html-cov.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var JSONCov = require(&#039;./json-cov&#039;)
  , fs = require(&#039;browser/fs&#039;);

/**
 * Expose `HTMLCov`.
 */

exports = module.exports = HTMLCov;

/**
 * Initialize a new `JsCoverage` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function HTMLCov(runner) {
  var jade = require(&#039;jade&#039;)
    , file = __dirname + &#039;/templates/coverage.jade&#039;
    , str = fs.readFileSync(file, &#039;utf8&#039;)
    , fn = jade.compile(str, { filename: file })
    , self = this;

  JSONCov.call(this, runner, false);

  runner.on(&#039;end&#039;, function(){
    process.stdout.write(fn({
        cov: self.cov
      , coverageClass: coverageClass
    }));
  });
}

/**
 * Return coverage class for `n`.
 *
 * @return {String}
 * @api private
 */

function coverageClass(n) {
  if (n &gt;= 75) return &#039;high&#039;;
  if (n &gt;= 50) return &#039;medium&#039;;
  if (n &gt;= 25) return &#039;low&#039;;
  return &#039;terrible&#039;;
}
}); // module: reporters/html-cov.js

require.register(&quot;reporters/html.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , utils = require(&#039;../utils&#039;)
  , Progress = require(&#039;../browser/progress&#039;)
  , escape = utils.escape;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval;

/**
 * Expose `HTML`.
 */

exports = module.exports = HTML;

/**
 * Stats template.
 */

var statsTemplate = &#039;&lt;ul id=&quot;mocha-stats&quot;&gt;&#039;
  + &#039;&lt;li class=&quot;progress&quot;&gt;&lt;canvas width=&quot;40&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt;&lt;/li&gt;&#039;
  + &#039;&lt;li class=&quot;passes&quot;&gt;&lt;a href=&quot;#&quot;&gt;passes:&lt;/a&gt; &lt;em&gt;0&lt;/em&gt;&lt;/li&gt;&#039;
  + &#039;&lt;li class=&quot;failures&quot;&gt;&lt;a href=&quot;#&quot;&gt;failures:&lt;/a&gt; &lt;em&gt;0&lt;/em&gt;&lt;/li&gt;&#039;
  + &#039;&lt;li class=&quot;duration&quot;&gt;duration: &lt;em&gt;0&lt;/em&gt;s&lt;/li&gt;&#039;
  + &#039;&lt;/ul&gt;&#039;;

/**
 * Initialize a new `HTML` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function HTML(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , total = runner.total
    , stat = fragment(statsTemplate)
    , items = stat.getElementsByTagName(&#039;li&#039;)
    , passes = items[1].getElementsByTagName(&#039;em&#039;)[0]
    , passesLink = items[1].getElementsByTagName(&#039;a&#039;)[0]
    , failures = items[2].getElementsByTagName(&#039;em&#039;)[0]
    , failuresLink = items[2].getElementsByTagName(&#039;a&#039;)[0]
    , duration = items[3].getElementsByTagName(&#039;em&#039;)[0]
    , canvas = stat.getElementsByTagName(&#039;canvas&#039;)[0]
    , report = fragment(&#039;&lt;ul id=&quot;mocha-report&quot;&gt;&lt;/ul&gt;&#039;)
    , stack = [report]
    , progress
    , ctx
    , root = document.getElementById(&#039;mocha&#039;);

  if (canvas.getContext) {
    var ratio = window.devicePixelRatio || 1;
    canvas.style.width = canvas.width;
    canvas.style.height = canvas.height;
    canvas.width *= ratio;
    canvas.height *= ratio;
    ctx = canvas.getContext(&#039;2d&#039;);
    ctx.scale(ratio, ratio);
    progress = new Progress;
  }

  if (!root) return error(&#039;#mocha div missing, add it to your document&#039;);

  // pass toggle
  on(passesLink, &#039;click&#039;, function(){
    unhide();
    var name = /pass/.test(report.className) ? &#039;&#039; : &#039; pass&#039;;
    report.className = report.className.replace(/fail|pass/g, &#039;&#039;) + name;
    if (report.className.trim()) hideSuitesWithout(&#039;test pass&#039;);
  });

  // failure toggle
  on(failuresLink, &#039;click&#039;, function(){
    unhide();
    var name = /fail/.test(report.className) ? &#039;&#039; : &#039; fail&#039;;
    report.className = report.className.replace(/fail|pass/g, &#039;&#039;) + name;
    if (report.className.trim()) hideSuitesWithout(&#039;test fail&#039;);
  });

  root.appendChild(stat);
  root.appendChild(report);

  if (progress) progress.size(40);

  runner.on(&#039;suite&#039;, function(suite){
    if (suite.root) return;

    // suite
    var url = self.suiteURL(suite);
    var el = fragment(&#039;&lt;li class=&quot;suite&quot;&gt;&lt;h1&gt;&lt;a href=&quot;%s&quot;&gt;%s&lt;/a&gt;&lt;/h1&gt;&lt;/li&gt;&#039;, url, escape(suite.title));

    // container
    stack[0].appendChild(el);
    stack.unshift(document.createElement(&#039;ul&#039;));
    el.appendChild(stack[0]);
  });

  runner.on(&#039;suite end&#039;, function(suite){
    if (suite.root) return;
    stack.shift();
  });

  runner.on(&#039;fail&#039;, function(test, err){
    if (&#039;hook&#039; == test.type) runner.emit(&#039;test end&#039;, test);
  });

  runner.on(&#039;test end&#039;, function(test){
    // TODO: add to stats
    var percent = stats.tests / this.total * 100 | 0;
    if (progress) progress.update(percent).draw(ctx);

    // update stats
    var ms = new Date - stats.start;
    text(passes, stats.passes);
    text(failures, stats.failures);
    text(duration, (ms / 1000).toFixed(2));

    // test
    if (&#039;passed&#039; == test.state) {
      var url = self.testURL(test);
      var el = fragment(&#039;&lt;li class=&quot;test pass %e&quot;&gt;&lt;h2&gt;%e&lt;span class=&quot;duration&quot;&gt;%ems&lt;/span&gt; &lt;a href=&quot;%s&quot; class=&quot;replay&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;/li&gt;&#039;, test.speed, test.title, test.duration, url);
    } else if (test.pending) {
      var el = fragment(&#039;&lt;li class=&quot;test pass pending&quot;&gt;&lt;h2&gt;%e&lt;/h2&gt;&lt;/li&gt;&#039;, test.title);
    } else {
      var el = fragment(&#039;&lt;li class=&quot;test fail&quot;&gt;&lt;h2&gt;%e &lt;a href=&quot;?grep=%e&quot; class=&quot;replay&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;/li&gt;&#039;, test.title, encodeURIComponent(test.fullTitle()));
      var str = test.err.stack || test.err.toString();

      // FF / Opera do not add the message
      if (!~str.indexOf(test.err.message)) {
        str = test.err.message + &#039;\n&#039; + str;
      }

      // &lt;=IE7 stringifies to [Object Error]. Since it can be overloaded, we
      // check for the result of the stringifying.
      if (&#039;[object Error]&#039; == str) str = test.err.message;

      // Safari doesn&#039;t give you a stack. Let&#039;s at least provide a source line.
      if (!test.err.stack &amp;&amp; test.err.sourceURL &amp;&amp; test.err.line !== undefined) {
        str += &quot;\n(&quot; + test.err.sourceURL + &quot;:&quot; + test.err.line + &quot;)&quot;;
      }

      el.appendChild(fragment(&#039;&lt;pre class=&quot;error&quot;&gt;%e&lt;/pre&gt;&#039;, str));
    }

    // toggle code
    // TODO: defer
    if (!test.pending) {
      var h2 = el.getElementsByTagName(&#039;h2&#039;)[0];

      on(h2, &#039;click&#039;, function(){
        pre.style.display = &#039;none&#039; == pre.style.display
          ? &#039;block&#039;
          : &#039;none&#039;;
      });

      var pre = fragment(&#039;&lt;pre&gt;&lt;code&gt;%e&lt;/code&gt;&lt;/pre&gt;&#039;, utils.clean(test.fn.toString()));
      el.appendChild(pre);
      pre.style.display = &#039;none&#039;;
    }

    // Don&#039;t call .appendChild if #mocha-report was already .shift()&#039;ed off the stack.
    if (stack[0]) stack[0].appendChild(el);
  });
}

/**
 * Provide suite URL
 *
 * @param {Object} [suite]
 */

HTML.prototype.suiteURL = function(suite){
  return &#039;?grep=&#039; + encodeURIComponent(suite.fullTitle());
};

/**
 * Provide test URL
 *
 * @param {Object} [test]
 */

HTML.prototype.testURL = function(test){
  return &#039;?grep=&#039; + encodeURIComponent(test.fullTitle());
};

/**
 * Display error `msg`.
 */

function error(msg) {
  document.body.appendChild(fragment(&#039;&lt;div id=&quot;mocha-error&quot;&gt;%s&lt;/div&gt;&#039;, msg));
}

/**
 * Return a DOM fragment from `html`.
 */

function fragment(html) {
  var args = arguments
    , div = document.createElement(&#039;div&#039;)
    , i = 1;

  div.innerHTML = html.replace(/%([se])/g, function(_, type){
    switch (type) {
      case &#039;s&#039;: return String(args[i++]);
      case &#039;e&#039;: return escape(args[i++]);
    }
  });

  return div.firstChild;
}

/**
 * Check for suites that do not have elements
 * with `classname`, and hide them.
 */

function hideSuitesWithout(classname) {
  var suites = document.getElementsByClassName(&#039;suite&#039;);
  for (var i = 0; i &lt; suites.length; i++) {
    var els = suites[i].getElementsByClassName(classname);
    if (0 == els.length) suites[i].className += &#039; hidden&#039;;
  }
}

/**
 * Unhide .hidden suites.
 */

function unhide() {
  var els = document.getElementsByClassName(&#039;suite hidden&#039;);
  for (var i = 0; i &lt; els.length; ++i) {
    els[i].className = els[i].className.replace(&#039;suite hidden&#039;, &#039;suite&#039;);
  }
}

/**
 * Set `el` text to `str`.
 */

function text(el, str) {
  if (el.textContent) {
    el.textContent = str;
  } else {
    el.innerText = str;
  }
}

/**
 * Listen on `event` with callback `fn`.
 */

function on(el, event, fn) {
  if (el.addEventListener) {
    el.addEventListener(event, fn, false);
  } else {
    el.attachEvent(&#039;on&#039; + event, fn);
  }
}

}); // module: reporters/html.js

require.register(&quot;reporters/index.js&quot;, function(module, exports, require){

exports.Base = require(&#039;./base&#039;);
exports.Dot = require(&#039;./dot&#039;);
exports.Doc = require(&#039;./doc&#039;);
exports.TAP = require(&#039;./tap&#039;);
exports.JSON = require(&#039;./json&#039;);
exports.HTML = require(&#039;./html&#039;);
exports.List = require(&#039;./list&#039;);
exports.Min = require(&#039;./min&#039;);
exports.Spec = require(&#039;./spec&#039;);
exports.Nyan = require(&#039;./nyan&#039;);
exports.XUnit = require(&#039;./xunit&#039;);
exports.Markdown = require(&#039;./markdown&#039;);
exports.Progress = require(&#039;./progress&#039;);
exports.Landing = require(&#039;./landing&#039;);
exports.JSONCov = require(&#039;./json-cov&#039;);
exports.HTMLCov = require(&#039;./html-cov&#039;);
exports.JSONStream = require(&#039;./json-stream&#039;);

}); // module: reporters/index.js

require.register(&quot;reporters/json-cov.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;);

/**
 * Expose `JSONCov`.
 */

exports = module.exports = JSONCov;

/**
 * Initialize a new `JsCoverage` reporter.
 *
 * @param {Runner} runner
 * @param {Boolean} output
 * @api public
 */

function JSONCov(runner, output) {
  var self = this
    , output = 1 == arguments.length ? true : output;

  Base.call(this, runner);

  var tests = []
    , failures = []
    , passes = [];

  runner.on(&#039;test end&#039;, function(test){
    tests.push(test);
  });

  runner.on(&#039;pass&#039;, function(test){
    passes.push(test);
  });

  runner.on(&#039;fail&#039;, function(test){
    failures.push(test);
  });

  runner.on(&#039;end&#039;, function(){
    var cov = global._$jscoverage || {};
    var result = self.cov = map(cov);
    result.stats = self.stats;
    result.tests = tests.map(clean);
    result.failures = failures.map(clean);
    result.passes = passes.map(clean);
    if (!output) return;
    process.stdout.write(JSON.stringify(result, null, 2 ));
  });
}

/**
 * Map jscoverage data to a JSON structure
 * suitable for reporting.
 *
 * @param {Object} cov
 * @return {Object}
 * @api private
 */

function map(cov) {
  var ret = {
      instrumentation: &#039;node-jscoverage&#039;
    , sloc: 0
    , hits: 0
    , misses: 0
    , coverage: 0
    , files: []
  };

  for (var filename in cov) {
    var data = coverage(filename, cov[filename]);
    ret.files.push(data);
    ret.hits += data.hits;
    ret.misses += data.misses;
    ret.sloc += data.sloc;
  }

  ret.files.sort(function(a, b) {
    return a.filename.localeCompare(b.filename);
  });

  if (ret.sloc &gt; 0) {
    ret.coverage = (ret.hits / ret.sloc) * 100;
  }

  return ret;
};

/**
 * Map jscoverage data for a single source file
 * to a JSON structure suitable for reporting.
 *
 * @param {String} filename name of the source file
 * @param {Object} data jscoverage coverage data
 * @return {Object}
 * @api private
 */

function coverage(filename, data) {
  var ret = {
    filename: filename,
    coverage: 0,
    hits: 0,
    misses: 0,
    sloc: 0,
    source: {}
  };

  data.source.forEach(function(line, num){
    num++;

    if (data[num] === 0) {
      ret.misses++;
      ret.sloc++;
    } else if (data[num] !== undefined) {
      ret.hits++;
      ret.sloc++;
    }

    ret.source[num] = {
        source: line
      , coverage: data[num] === undefined
        ? &#039;&#039;
        : data[num]
    };
  });

  ret.coverage = ret.hits / ret.sloc * 100;

  return ret;
}

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @param {Object} test
 * @return {Object}
 * @api private
 */

function clean(test) {
  return {
      title: test.title
    , fullTitle: test.fullTitle()
    , duration: test.duration
  }
}

}); // module: reporters/json-cov.js

require.register(&quot;reporters/json-stream.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , color = Base.color;

/**
 * Expose `List`.
 */

exports = module.exports = List;

/**
 * Initialize a new `List` test reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function List(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , total = runner.total;

  runner.on(&#039;start&#039;, function(){
    console.log(JSON.stringify([&#039;start&#039;, { total: total }]));
  });

  runner.on(&#039;pass&#039;, function(test){
    console.log(JSON.stringify([&#039;pass&#039;, clean(test)]));
  });

  runner.on(&#039;fail&#039;, function(test, err){
    console.log(JSON.stringify([&#039;fail&#039;, clean(test)]));
  });

  runner.on(&#039;end&#039;, function(){
    process.stdout.write(JSON.stringify([&#039;end&#039;, self.stats]));
  });
}

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @param {Object} test
 * @return {Object}
 * @api private
 */

function clean(test) {
  return {
      title: test.title
    , fullTitle: test.fullTitle()
    , duration: test.duration
  }
}
}); // module: reporters/json-stream.js

require.register(&quot;reporters/json.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , cursor = Base.cursor
  , color = Base.color;

/**
 * Expose `JSON`.
 */

exports = module.exports = JSONReporter;

/**
 * Initialize a new `JSON` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function JSONReporter(runner) {
  var self = this;
  Base.call(this, runner);

  var tests = []
    , failures = []
    , passes = [];

  runner.on(&#039;test end&#039;, function(test){
    tests.push(test);
  });

  runner.on(&#039;pass&#039;, function(test){
    passes.push(test);
  });

  runner.on(&#039;fail&#039;, function(test){
    failures.push(test);
  });

  runner.on(&#039;end&#039;, function(){
    var obj = {
        stats: self.stats
      , tests: tests.map(clean)
      , failures: failures.map(clean)
      , passes: passes.map(clean)
    };

    process.stdout.write(JSON.stringify(obj, null, 2));
  });
}

/**
 * Return a plain-object representation of `test`
 * free of cyclic properties etc.
 *
 * @param {Object} test
 * @return {Object}
 * @api private
 */

function clean(test) {
  return {
      title: test.title
    , fullTitle: test.fullTitle()
    , duration: test.duration
  }
}
}); // module: reporters/json.js

require.register(&quot;reporters/landing.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , cursor = Base.cursor
  , color = Base.color;

/**
 * Expose `Landing`.
 */

exports = module.exports = Landing;

/**
 * Airplane color.
 */

Base.colors.plane = 0;

/**
 * Airplane crash color.
 */

Base.colors[&#039;plane crash&#039;] = 31;

/**
 * Runway color.
 */

Base.colors.runway = 90;

/**
 * Initialize a new `Landing` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function Landing(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , width = Base.window.width * .75 | 0
    , total = runner.total
    , stream = process.stdout
    , plane = color(&#039;plane&#039;, &#039;&#039;)
    , crashed = -1
    , n = 0;

  function runway() {
    var buf = Array(width).join(&#039;-&#039;);
    return &#039;  &#039; + color(&#039;runway&#039;, buf);
  }

  runner.on(&#039;start&#039;, function(){
    stream.write(&#039;\n  &#039;);
    cursor.hide();
  });

  runner.on(&#039;test end&#039;, function(test){
    // check if the plane crashed
    var col = -1 == crashed
      ? width * ++n / total | 0
      : crashed;

    // show the crash
    if (&#039;failed&#039; == test.state) {
      plane = color(&#039;plane crash&#039;, &#039;&#039;);
      crashed = col;
    }

    // render landing strip
    stream.write(&#039;\u001b[4F\n\n&#039;);
    stream.write(runway());
    stream.write(&#039;\n  &#039;);
    stream.write(color(&#039;runway&#039;, Array(col).join(&#039;&#039;)));
    stream.write(plane)
    stream.write(color(&#039;runway&#039;, Array(width - col).join(&#039;&#039;) + &#039;\n&#039;));
    stream.write(runway());
    stream.write(&#039;\u001b[0m&#039;);
  });

  runner.on(&#039;end&#039;, function(){
    cursor.show();
    console.log();
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
Landing.prototype = new F;
Landing.prototype.constructor = Landing;

}); // module: reporters/landing.js

require.register(&quot;reporters/list.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , cursor = Base.cursor
  , color = Base.color;

/**
 * Expose `List`.
 */

exports = module.exports = List;

/**
 * Initialize a new `List` test reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function List(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , n = 0;

  runner.on(&#039;start&#039;, function(){
    console.log();
  });

  runner.on(&#039;test&#039;, function(test){
    process.stdout.write(color(&#039;pass&#039;, &#039;    &#039; + test.fullTitle() + &#039;: &#039;));
  });

  runner.on(&#039;pending&#039;, function(test){
    var fmt = color(&#039;checkmark&#039;, &#039;  -&#039;)
      + color(&#039;pending&#039;, &#039; %s&#039;);
    console.log(fmt, test.fullTitle());
  });

  runner.on(&#039;pass&#039;, function(test){
    var fmt = color(&#039;checkmark&#039;, &#039;  &#039;+Base.symbols.dot)
      + color(&#039;pass&#039;, &#039; %s: &#039;)
      + color(test.speed, &#039;%dms&#039;);
    cursor.CR();
    console.log(fmt, test.fullTitle(), test.duration);
  });

  runner.on(&#039;fail&#039;, function(test, err){
    cursor.CR();
    console.log(color(&#039;fail&#039;, &#039;  %d) %s&#039;), ++n, test.fullTitle());
  });

  runner.on(&#039;end&#039;, self.epilogue.bind(self));
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
List.prototype = new F;
List.prototype.constructor = List;


}); // module: reporters/list.js

require.register(&quot;reporters/markdown.js&quot;, function(module, exports, require){
/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , utils = require(&#039;../utils&#039;);

/**
 * Expose `Markdown`.
 */

exports = module.exports = Markdown;

/**
 * Initialize a new `Markdown` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function Markdown(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , level = 0
    , buf = &#039;&#039;;

  function title(str) {
    return Array(level).join(&#039;#&#039;) + &#039; &#039; + str;
  }

  function indent() {
    return Array(level).join(&#039;  &#039;);
  }

  function mapTOC(suite, obj) {
    var ret = obj;
    obj = obj[suite.title] = obj[suite.title] || { suite: suite };
    suite.suites.forEach(function(suite){
      mapTOC(suite, obj);
    });
    return ret;
  }

  function stringifyTOC(obj, level) {
    ++level;
    var buf = &#039;&#039;;
    var link;
    for (var key in obj) {
      if (&#039;suite&#039; == key) continue;
      if (key) link = &#039; - [&#039; + key + &#039;](#&#039; + utils.slug(obj[key].suite.fullTitle()) + &#039;)\n&#039;;
      if (key) buf += Array(level).join(&#039;  &#039;) + link;
      buf += stringifyTOC(obj[key], level);
    }
    --level;
    return buf;
  }

  function generateTOC(suite) {
    var obj = mapTOC(suite, {});
    return stringifyTOC(obj, 0);
  }

  generateTOC(runner.suite);

  runner.on(&#039;suite&#039;, function(suite){
    ++level;
    var slug = utils.slug(suite.fullTitle());
    buf += &#039;&lt;a name=&quot;&#039; + slug + &#039;&quot;&gt;&lt;/a&gt;&#039; + &#039;\n&#039;;
    buf += title(suite.title) + &#039;\n&#039;;
  });

  runner.on(&#039;suite end&#039;, function(suite){
    --level;
  });

  runner.on(&#039;pass&#039;, function(test){
    var code = utils.clean(test.fn.toString());
    buf += test.title + &#039;.\n&#039;;
    buf += &#039;\n```js\n&#039;;
    buf += code + &#039;\n&#039;;
    buf += &#039;```\n\n&#039;;
  });

  runner.on(&#039;end&#039;, function(){
    process.stdout.write(&#039;# TOC\n&#039;);
    process.stdout.write(generateTOC(runner.suite));
    process.stdout.write(buf);
  });
}
}); // module: reporters/markdown.js

require.register(&quot;reporters/min.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;);

/**
 * Expose `Min`.
 */

exports = module.exports = Min;

/**
 * Initialize a new `Min` minimal test reporter (best used with --watch).
 *
 * @param {Runner} runner
 * @api public
 */

function Min(runner) {
  Base.call(this, runner);

  runner.on(&#039;start&#039;, function(){
    // clear screen
    process.stdout.write(&#039;\u001b[2J&#039;);
    // set cursor position
    process.stdout.write(&#039;\u001b[1;3H&#039;);
  });

  runner.on(&#039;end&#039;, this.epilogue.bind(this));
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
Min.prototype = new F;
Min.prototype.constructor = Min;


}); // module: reporters/min.js

require.register(&quot;reporters/nyan.js&quot;, function(module, exports, require){
/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , color = Base.color;

/**
 * Expose `Dot`.
 */

exports = module.exports = NyanCat;

/**
 * Initialize a new `Dot` matrix test reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function NyanCat(runner) {
  Base.call(this, runner);
  var self = this
    , stats = this.stats
    , width = Base.window.width * .75 | 0
    , rainbowColors = this.rainbowColors = self.generateColors()
    , colorIndex = this.colorIndex = 0
    , numerOfLines = this.numberOfLines = 4
    , trajectories = this.trajectories = [[], [], [], []]
    , nyanCatWidth = this.nyanCatWidth = 11
    , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)
    , scoreboardWidth = this.scoreboardWidth = 5
    , tick = this.tick = 0
    , n = 0;

  runner.on(&#039;start&#039;, function(){
    Base.cursor.hide();
    self.draw();
  });

  runner.on(&#039;pending&#039;, function(test){
    self.draw();
  });

  runner.on(&#039;pass&#039;, function(test){
    self.draw();
  });

  runner.on(&#039;fail&#039;, function(test, err){
    self.draw();
  });

  runner.on(&#039;end&#039;, function(){
    Base.cursor.show();
    for (var i = 0; i &lt; self.numberOfLines; i++) write(&#039;\n&#039;);
    self.epilogue();
  });
}

/**
 * Draw the nyan cat
 *
 * @api private
 */

NyanCat.prototype.draw = function(){
  this.appendRainbow();
  this.drawScoreboard();
  this.drawRainbow();
  this.drawNyanCat();
  this.tick = !this.tick;
};

/**
 * Draw the &quot;scoreboard&quot; showing the number
 * of passes, failures and pending tests.
 *
 * @api private
 */

NyanCat.prototype.drawScoreboard = function(){
  var stats = this.stats;
  var colors = Base.colors;

  function draw(color, n) {
    write(&#039; &#039;);
    write(&#039;\u001b[&#039; + color + &#039;m&#039; + n + &#039;\u001b[0m&#039;);
    write(&#039;\n&#039;);
  }

  draw(colors.green, stats.passes);
  draw(colors.fail, stats.failures);
  draw(colors.pending, stats.pending);
  write(&#039;\n&#039;);

  this.cursorUp(this.numberOfLines);
};

/**
 * Append the rainbow.
 *
 * @api private
 */

NyanCat.prototype.appendRainbow = function(){
  var segment = this.tick ? &#039;_&#039; : &#039;-&#039;;
  var rainbowified = this.rainbowify(segment);

  for (var index = 0; index &lt; this.numberOfLines; index++) {
    var trajectory = this.trajectories[index];
    if (trajectory.length &gt;= this.trajectoryWidthMax) trajectory.shift();
    trajectory.push(rainbowified);
  }
};

/**
 * Draw the rainbow.
 *
 * @api private
 */

NyanCat.prototype.drawRainbow = function(){
  var self = this;

  this.trajectories.forEach(function(line, index) {
    write(&#039;\u001b[&#039; + self.scoreboardWidth + &#039;C&#039;);
    write(line.join(&#039;&#039;));
    write(&#039;\n&#039;);
  });

  this.cursorUp(this.numberOfLines);
};

/**
 * Draw the nyan cat
 *
 * @api private
 */

NyanCat.prototype.drawNyanCat = function() {
  var self = this;
  var startWidth = this.scoreboardWidth + this.trajectories[0].length;
  var color = &#039;\u001b[&#039; + startWidth + &#039;C&#039;;
  var padding = &#039;&#039;;

  write(color);
  write(&#039;_,------,&#039;);
  write(&#039;\n&#039;);

  write(color);
  padding = self.tick ? &#039;  &#039; : &#039;   &#039;;
  write(&#039;_|&#039; + padding + &#039;/\\_/\\ &#039;);
  write(&#039;\n&#039;);

  write(color);
  padding = self.tick ? &#039;_&#039; : &#039;__&#039;;
  var tail = self.tick ? &#039;~&#039; : &#039;^&#039;;
  var face;
  write(tail + &#039;|&#039; + padding + this.face() + &#039; &#039;);
  write(&#039;\n&#039;);

  write(color);
  padding = self.tick ? &#039; &#039; : &#039;  &#039;;
  write(padding + &#039;&quot;&quot;  &quot;&quot; &#039;);
  write(&#039;\n&#039;);

  this.cursorUp(this.numberOfLines);
};

/**
 * Draw nyan cat face.
 *
 * @return {String}
 * @api private
 */

NyanCat.prototype.face = function() {
  var stats = this.stats;
  if (stats.failures) {
    return &#039;( x .x)&#039;;
  } else if (stats.pending) {
    return &#039;( o .o)&#039;;
  } else if(stats.passes) {
    return &#039;( ^ .^)&#039;;
  } else {
    return &#039;( - .-)&#039;;
  }
}

/**
 * Move cursor up `n`.
 *
 * @param {Number} n
 * @api private
 */

NyanCat.prototype.cursorUp = function(n) {
  write(&#039;\u001b[&#039; + n + &#039;A&#039;);
};

/**
 * Move cursor down `n`.
 *
 * @param {Number} n
 * @api private
 */

NyanCat.prototype.cursorDown = function(n) {
  write(&#039;\u001b[&#039; + n + &#039;B&#039;);
};

/**
 * Generate rainbow colors.
 *
 * @return {Array}
 * @api private
 */

NyanCat.prototype.generateColors = function(){
  var colors = [];

  for (var i = 0; i &lt; (6 * 7); i++) {
    var pi3 = Math.floor(Math.PI / 3);
    var n = (i * (1.0 / 6));
    var r = Math.floor(3 * Math.sin(n) + 3);
    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
    colors.push(36 * r + 6 * g + b + 16);
  }

  return colors;
};

/**
 * Apply rainbow to the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

NyanCat.prototype.rainbowify = function(str){
  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
  this.colorIndex += 1;
  return &#039;\u001b[38;5;&#039; + color + &#039;m&#039; + str + &#039;\u001b[0m&#039;;
};

/**
 * Stdout helper.
 */

function write(string) {
  process.stdout.write(string);
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
NyanCat.prototype = new F;
NyanCat.prototype.constructor = NyanCat;


}); // module: reporters/nyan.js

require.register(&quot;reporters/progress.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , cursor = Base.cursor
  , color = Base.color;

/**
 * Expose `Progress`.
 */

exports = module.exports = Progress;

/**
 * General progress bar color.
 */

Base.colors.progress = 90;

/**
 * Initialize a new `Progress` bar test reporter.
 *
 * @param {Runner} runner
 * @param {Object} options
 * @api public
 */

function Progress(runner, options) {
  Base.call(this, runner);

  var self = this
    , options = options || {}
    , stats = this.stats
    , width = Base.window.width * .50 | 0
    , total = runner.total
    , complete = 0
    , max = Math.max;

  // default chars
  options.open = options.open || &#039;[&#039;;
  options.complete = options.complete || &#039;&#039;;
  options.incomplete = options.incomplete || Base.symbols.dot;
  options.close = options.close || &#039;]&#039;;
  options.verbose = false;

  // tests started
  runner.on(&#039;start&#039;, function(){
    console.log();
    cursor.hide();
  });

  // tests complete
  runner.on(&#039;test end&#039;, function(){
    complete++;
    var incomplete = total - complete
      , percent = complete / total
      , n = width * percent | 0
      , i = width - n;

    cursor.CR();
    process.stdout.write(&#039;\u001b[J&#039;);
    process.stdout.write(color(&#039;progress&#039;, &#039;  &#039; + options.open));
    process.stdout.write(Array(n).join(options.complete));
    process.stdout.write(Array(i).join(options.incomplete));
    process.stdout.write(color(&#039;progress&#039;, options.close));
    if (options.verbose) {
      process.stdout.write(color(&#039;progress&#039;, &#039; &#039; + complete + &#039; of &#039; + total));
    }
  });

  // tests are complete, output some stats
  // and the failures if any
  runner.on(&#039;end&#039;, function(){
    cursor.show();
    console.log();
    self.epilogue();
  });
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
Progress.prototype = new F;
Progress.prototype.constructor = Progress;


}); // module: reporters/progress.js

require.register(&quot;reporters/spec.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , cursor = Base.cursor
  , color = Base.color;

/**
 * Expose `Spec`.
 */

exports = module.exports = Spec;

/**
 * Initialize a new `Spec` test reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function Spec(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , indents = 0
    , n = 0;

  function indent() {
    return Array(indents).join(&#039;  &#039;)
  }

  runner.on(&#039;start&#039;, function(){
    console.log();
  });

  runner.on(&#039;suite&#039;, function(suite){
    ++indents;
    console.log(color(&#039;suite&#039;, &#039;%s%s&#039;), indent(), suite.title);
  });

  runner.on(&#039;suite end&#039;, function(suite){
    --indents;
    if (1 == indents) console.log();
  });

  runner.on(&#039;pending&#039;, function(test){
    var fmt = indent() + color(&#039;pending&#039;, &#039;  - %s&#039;);
    console.log(fmt, test.title);
  });

  runner.on(&#039;pass&#039;, function(test){
    if (&#039;fast&#039; == test.speed) {
      var fmt = indent()
        + color(&#039;checkmark&#039;, &#039;  &#039; + Base.symbols.ok)
        + color(&#039;pass&#039;, &#039; %s &#039;);
      cursor.CR();
      console.log(fmt, test.title);
    } else {
      var fmt = indent()
        + color(&#039;checkmark&#039;, &#039;  &#039; + Base.symbols.ok)
        + color(&#039;pass&#039;, &#039; %s &#039;)
        + color(test.speed, &#039;(%dms)&#039;);
      cursor.CR();
      console.log(fmt, test.title, test.duration);
    }
  });

  runner.on(&#039;fail&#039;, function(test, err){
    cursor.CR();
    console.log(indent() + color(&#039;fail&#039;, &#039;  %d) %s&#039;), ++n, test.title);
  });

  runner.on(&#039;end&#039;, self.epilogue.bind(self));
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
Spec.prototype = new F;
Spec.prototype.constructor = Spec;


}); // module: reporters/spec.js

require.register(&quot;reporters/tap.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , cursor = Base.cursor
  , color = Base.color;

/**
 * Expose `TAP`.
 */

exports = module.exports = TAP;

/**
 * Initialize a new `TAP` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function TAP(runner) {
  Base.call(this, runner);

  var self = this
    , stats = this.stats
    , n = 1
    , passes = 0
    , failures = 0;

  runner.on(&#039;start&#039;, function(){
    var total = runner.grepTotal(runner.suite);
    console.log(&#039;%d..%d&#039;, 1, total);
  });

  runner.on(&#039;test end&#039;, function(){
    ++n;
  });

  runner.on(&#039;pending&#039;, function(test){
    console.log(&#039;ok %d %s # SKIP -&#039;, n, title(test));
  });

  runner.on(&#039;pass&#039;, function(test){
    passes++;
    console.log(&#039;ok %d %s&#039;, n, title(test));
  });

  runner.on(&#039;fail&#039;, function(test, err){
    failures++;
    console.log(&#039;not ok %d %s&#039;, n, title(test));
    if (err.stack) console.log(err.stack.replace(/^/gm, &#039;  &#039;));
  });

  runner.on(&#039;end&#039;, function(){
    console.log(&#039;# tests &#039; + (passes + failures));
    console.log(&#039;# pass &#039; + passes);
    console.log(&#039;# fail &#039; + failures);
  });
}

/**
 * Return a TAP-safe title of `test`
 *
 * @param {Object} test
 * @return {String}
 * @api private
 */

function title(test) {
  return test.fullTitle().replace(/#/g, &#039;&#039;);
}

}); // module: reporters/tap.js

require.register(&quot;reporters/xunit.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Base = require(&#039;./base&#039;)
  , utils = require(&#039;../utils&#039;)
  , escape = utils.escape;

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval;

/**
 * Expose `XUnit`.
 */

exports = module.exports = XUnit;

/**
 * Initialize a new `XUnit` reporter.
 *
 * @param {Runner} runner
 * @api public
 */

function XUnit(runner) {
  Base.call(this, runner);
  var stats = this.stats
    , tests = []
    , self = this;

  runner.on(&#039;pending&#039;, function(test){
    tests.push(test);
  });

  runner.on(&#039;pass&#039;, function(test){
    tests.push(test);
  });

  runner.on(&#039;fail&#039;, function(test){
    tests.push(test);
  });

  runner.on(&#039;end&#039;, function(){
    console.log(tag(&#039;testsuite&#039;, {
        name: &#039;Mocha Tests&#039;
      , tests: stats.tests
      , failures: stats.failures
      , errors: stats.failures
      , skipped: stats.tests - stats.failures - stats.passes
      , timestamp: (new Date).toUTCString()
      , time: (stats.duration / 1000) || 0
    }, false));

    tests.forEach(test);
    console.log(&#039;&lt;/testsuite&gt;&#039;);
  });
}

/**
 * Inherit from `Base.prototype`.
 */

function F(){};
F.prototype = Base.prototype;
XUnit.prototype = new F;
XUnit.prototype.constructor = XUnit;


/**
 * Output tag for the given `test.`
 */

function test(test) {
  var attrs = {
      classname: test.parent.fullTitle()
    , name: test.title
    , time: (test.duration / 1000) || 0
  };

  if (&#039;failed&#039; == test.state) {
    var err = test.err;
    attrs.message = escape(err.message);
    console.log(tag(&#039;testcase&#039;, attrs, false, tag(&#039;failure&#039;, attrs, false, cdata(err.stack))));
  } else if (test.pending) {
    console.log(tag(&#039;testcase&#039;, attrs, false, tag(&#039;skipped&#039;, {}, true)));
  } else {
    console.log(tag(&#039;testcase&#039;, attrs, true) );
  }
}

/**
 * HTML tag helper.
 */

function tag(name, attrs, close, content) {
  var end = close ? &#039;/&gt;&#039; : &#039;&gt;&#039;
    , pairs = []
    , tag;

  for (var key in attrs) {
    pairs.push(key + &#039;=&quot;&#039; + escape(attrs[key]) + &#039;&quot;&#039;);
  }

  tag = &#039;&lt;&#039; + name + (pairs.length ? &#039; &#039; + pairs.join(&#039; &#039;) : &#039;&#039;) + end;
  if (content) tag += content + &#039;&lt;/&#039; + name + end;
  return tag;
}

/**
 * Return cdata escaped CDATA `str`.
 */

function cdata(str) {
  return &#039;&lt;![CDATA[&#039; + escape(str) + &#039;]]&gt;&#039;;
}

}); // module: reporters/xunit.js

require.register(&quot;runnable.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var EventEmitter = require(&#039;browser/events&#039;).EventEmitter
  , debug = require(&#039;browser/debug&#039;)(&#039;mocha:runnable&#039;)
  , milliseconds = require(&#039;./ms&#039;);

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date
  , setTimeout = global.setTimeout
  , setInterval = global.setInterval
  , clearTimeout = global.clearTimeout
  , clearInterval = global.clearInterval;

/**
 * Object#toString().
 */

var toString = Object.prototype.toString;

/**
 * Expose `Runnable`.
 */

module.exports = Runnable;

/**
 * Initialize a new `Runnable` with the given `title` and callback `fn`.
 *
 * @param {String} title
 * @param {Function} fn
 * @api private
 */

function Runnable(title, fn) {
  this.title = title;
  this.fn = fn;
  this.async = fn &amp;&amp; fn.length;
  this.sync = ! this.async;
  this._timeout = 2000;
  this._slow = 75;
  this.timedOut = false;
}

/**
 * Inherit from `EventEmitter.prototype`.
 */

function F(){};
F.prototype = EventEmitter.prototype;
Runnable.prototype = new F;
Runnable.prototype.constructor = Runnable;


/**
 * Set &amp; get timeout `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */

Runnable.prototype.timeout = function(ms){
  if (0 == arguments.length) return this._timeout;
  if (&#039;string&#039; == typeof ms) ms = milliseconds(ms);
  debug(&#039;timeout %d&#039;, ms);
  this._timeout = ms;
  if (this.timer) this.resetTimeout();
  return this;
};

/**
 * Set &amp; get slow `ms`.
 *
 * @param {Number|String} ms
 * @return {Runnable|Number} ms or self
 * @api private
 */

Runnable.prototype.slow = function(ms){
  if (0 === arguments.length) return this._slow;
  if (&#039;string&#039; == typeof ms) ms = milliseconds(ms);
  debug(&#039;timeout %d&#039;, ms);
  this._slow = ms;
  return this;
};

/**
 * Return the full title generated by recursively
 * concatenating the parent&#039;s full title.
 *
 * @return {String}
 * @api public
 */

Runnable.prototype.fullTitle = function(){
  return this.parent.fullTitle() + &#039; &#039; + this.title;
};

/**
 * Clear the timeout.
 *
 * @api private
 */

Runnable.prototype.clearTimeout = function(){
  clearTimeout(this.timer);
};

/**
 * Inspect the runnable void of private properties.
 *
 * @return {String}
 * @api private
 */

Runnable.prototype.inspect = function(){
  return JSON.stringify(this, function(key, val){
    if (&#039;_&#039; == key[0]) return;
    if (&#039;parent&#039; == key) return &#039;#&lt;Suite&gt;&#039;;
    if (&#039;ctx&#039; == key) return &#039;#&lt;Context&gt;&#039;;
    return val;
  }, 2);
};

/**
 * Reset the timeout.
 *
 * @api private
 */

Runnable.prototype.resetTimeout = function(){
  var self = this;
  var ms = this.timeout() || 1e9;

  this.clearTimeout();
  this.timer = setTimeout(function(){
    self.callback(new Error(&#039;timeout of &#039; + ms + &#039;ms exceeded&#039;));
    self.timedOut = true;
  }, ms);
};

/**
 * Whitelist these globals for this test run
 *
 * @api private
 */
Runnable.prototype.globals = function(arr){
  var self = this;
  this._allowedGlobals = arr;
};

/**
 * Run the test and invoke `fn(err)`.
 *
 * @param {Function} fn
 * @api private
 */

Runnable.prototype.run = function(fn){
  var self = this
    , ms = this.timeout()
    , start = new Date
    , ctx = this.ctx
    , finished
    , emitted;

  if (ctx) ctx.runnable(this);

  // called multiple times
  function multiple(err) {
    if (emitted) return;
    emitted = true;
    self.emit(&#039;error&#039;, err || new Error(&#039;done() called multiple times&#039;));
  }

  // finished
  function done(err) {
    if (self.timedOut) return;
    if (finished) return multiple(err);
    self.clearTimeout();
    self.duration = new Date - start;
    finished = true;
    fn(err);
  }

  // for .resetTimeout()
  this.callback = done;

  // explicit async with `done` argument
  if (this.async) {
    this.resetTimeout();

    try {
      this.fn.call(ctx, function(err){
        if (err instanceof Error || toString.call(err) === &quot;[object Error]&quot;) return done(err);
        if (null != err) return done(new Error(&#039;done() invoked with non-Error: &#039; + err));
        done();
      });
    } catch (err) {
      done(err);
    }
    return;
  }

  if (this.asyncOnly) {
    return done(new Error(&#039;--async-only option in use without declaring `done()`&#039;));
  }

  // sync or promise-returning
  try {
    if (this.pending) {
      done();
    } else {
      callFn(this.fn);
    }
  } catch (err) {
    done(err);
  }

  function callFn(fn) {
    var result = fn.call(ctx);
    if (result &amp;&amp; typeof result.then === &#039;function&#039;) {
      self.resetTimeout();
      result.then(function(){ done() }, done);
    } else {
      done();
    }
  }
};

}); // module: runnable.js

require.register(&quot;runner.js&quot;, function(module, exports, require){
/**
 * Module dependencies.
 */

var EventEmitter = require(&#039;browser/events&#039;).EventEmitter
  , debug = require(&#039;browser/debug&#039;)(&#039;mocha:runner&#039;)
  , Test = require(&#039;./test&#039;)
  , utils = require(&#039;./utils&#039;)
  , filter = utils.filter
  , keys = utils.keys;

/**
 * Non-enumerable globals.
 */

var globals = [
  &#039;setTimeout&#039;,
  &#039;clearTimeout&#039;,
  &#039;setInterval&#039;,
  &#039;clearInterval&#039;,
  &#039;XMLHttpRequest&#039;,
  &#039;Date&#039;
];

/**
 * Expose `Runner`.
 */

module.exports = Runner;

/**
 * Initialize a `Runner` for the given `suite`.
 *
 * Events:
 *
 *   - `start`  execution started
 *   - `end`  execution complete
 *   - `suite`  (suite) test suite execution started
 *   - `suite end`  (suite) all tests (and sub-suites) have finished
 *   - `test`  (test) test execution started
 *   - `test end`  (test) test completed
 *   - `hook`  (hook) hook execution started
 *   - `hook end`  (hook) hook complete
 *   - `pass`  (test) test passed
 *   - `fail`  (test, err) test failed
 *   - `pending`  (test) test pending
 *
 * @api public
 */

function Runner(suite) {
  var self = this;
  this._globals = [];
  this._abort = false;
  this.suite = suite;
  this.total = suite.total();
  this.failures = 0;
  this.on(&#039;test end&#039;, function(test){ self.checkGlobals(test); });
  this.on(&#039;hook end&#039;, function(hook){ self.checkGlobals(hook); });
  this.grep(/.*/);
  this.globals(this.globalProps().concat(extraGlobals()));
}

/**
 * Wrapper for setImmediate, process.nextTick, or browser polyfill.
 *
 * @param {Function} fn
 * @api private
 */

Runner.immediately = global.setImmediate || process.nextTick;

/**
 * Inherit from `EventEmitter.prototype`.
 */

function F(){};
F.prototype = EventEmitter.prototype;
Runner.prototype = new F;
Runner.prototype.constructor = Runner;


/**
 * Run tests with full titles matching `re`. Updates runner.total
 * with number of tests matched.
 *
 * @param {RegExp} re
 * @param {Boolean} invert
 * @return {Runner} for chaining
 * @api public
 */

Runner.prototype.grep = function(re, invert){
  debug(&#039;grep %s&#039;, re);
  this._grep = re;
  this._invert = invert;
  this.total = this.grepTotal(this.suite);
  return this;
};

/**
 * Returns the number of tests matching the grep search for the
 * given suite.
 *
 * @param {Suite} suite
 * @return {Number}
 * @api public
 */

Runner.prototype.grepTotal = function(suite) {
  var self = this;
  var total = 0;

  suite.eachTest(function(test){
    var match = self._grep.test(test.fullTitle());
    if (self._invert) match = !match;
    if (match) total++;
  });

  return total;
};

/**
 * Return a list of global properties.
 *
 * @return {Array}
 * @api private
 */

Runner.prototype.globalProps = function() {
  var props = utils.keys(global);

  // non-enumerables
  for (var i = 0; i &lt; globals.length; ++i) {
    if (~utils.indexOf(props, globals[i])) continue;
    props.push(globals[i]);
  }

  return props;
};

/**
 * Allow the given `arr` of globals.
 *
 * @param {Array} arr
 * @return {Runner} for chaining
 * @api public
 */

Runner.prototype.globals = function(arr){
  if (0 == arguments.length) return this._globals;
  debug(&#039;globals %j&#039;, arr);
  this._globals = this._globals.concat(arr);
  return this;
};

/**
 * Check for global variable leaks.
 *
 * @api private
 */

Runner.prototype.checkGlobals = function(test){
  if (this.ignoreLeaks) return;
  var ok = this._globals;

  var globals = this.globalProps();
  var isNode = process.kill;
  var leaks;

  if (test) {
    ok = ok.concat(test._allowedGlobals || []);
  }

  if(this.prevGlobalsLength == globals.length) return;
  this.prevGlobalsLength = globals.length;

  leaks = filterLeaks(ok, globals);
  this._globals = this._globals.concat(leaks);

  if (leaks.length &gt; 1) {
    this.fail(test, new Error(&#039;global leaks detected: &#039; + leaks.join(&#039;, &#039;) + &#039;&#039;));
  } else if (leaks.length) {
    this.fail(test, new Error(&#039;global leak detected: &#039; + leaks[0]));
  }
};

/**
 * Fail the given `test`.
 *
 * @param {Test} test
 * @param {Error} err
 * @api private
 */

Runner.prototype.fail = function(test, err){
  ++this.failures;
  test.state = &#039;failed&#039;;

  if (&#039;string&#039; == typeof err) {
    err = new Error(&#039;the string &quot;&#039; + err + &#039;&quot; was thrown, throw an Error :)&#039;);
  }

  this.emit(&#039;fail&#039;, test, err);
};

/**
 * Fail the given `hook` with `err`.
 *
 * Hook failures work in the following pattern:
 * - If bail, then exit
 * - Failed `before` hook skips all tests in a suite and subsuites,
 *   but jumps to corresponding `after` hook
 * - Failed `before each` hook skips remaining tests in a
 *   suite and jumps to corresponding `after each` hook,
 *   which is run only once
 * - Failed `after` hook does not alter
 *   execution order
 * - Failed `after each` hook skips remaining tests in a
 *   suite and subsuites, but executes other `after each`
 *   hooks
 *
 * @param {Hook} hook
 * @param {Error} err
 * @api private
 */

Runner.prototype.failHook = function(hook, err){
  this.fail(hook, err);
  if (this.suite.bail()) {
    this.emit(&#039;end&#039;);
  }
};

/**
 * Run hook `name` callbacks and then invoke `fn()`.
 *
 * @param {String} name
 * @param {Function} function
 * @api private
 */

Runner.prototype.hook = function(name, fn){
  var suite = this.suite
    , hooks = suite[&#039;_&#039; + name]
    , self = this
    , timer;

  function next(i) {
    var hook = hooks[i];
    if (!hook) return fn();
    if (self.failures &amp;&amp; suite.bail()) return fn();
    self.currentRunnable = hook;

    hook.ctx.currentTest = self.test;

    self.emit(&#039;hook&#039;, hook);

    hook.on(&#039;error&#039;, function(err){
      self.failHook(hook, err);
    });

    hook.run(function(err){
      hook.removeAllListeners(&#039;error&#039;);
      var testError = hook.error();
      if (testError) self.fail(self.test, testError);
      if (err) {
        self.failHook(hook, err);

        // stop executing hooks, notify callee of hook err
        return fn(err);
      }
      self.emit(&#039;hook end&#039;, hook);
      delete hook.ctx.currentTest;
      next(++i);
    });
  }

  Runner.immediately(function(){
    next(0);
  });
};

/**
 * Run hook `name` for the given array of `suites`
 * in order, and callback `fn(err, errSuite)`.
 *
 * @param {String} name
 * @param {Array} suites
 * @param {Function} fn
 * @api private
 */

Runner.prototype.hooks = function(name, suites, fn){
  var self = this
    , orig = this.suite;

  function next(suite) {
    self.suite = suite;

    if (!suite) {
      self.suite = orig;
      return fn();
    }

    self.hook(name, function(err){
      if (err) {
        var errSuite = self.suite;
        self.suite = orig;
        return fn(err, errSuite);
      }

      next(suites.pop());
    });
  }

  next(suites.pop());
};

/**
 * Run hooks from the top level down.
 *
 * @param {String} name
 * @param {Function} fn
 * @api private
 */

Runner.prototype.hookUp = function(name, fn){
  var suites = [this.suite].concat(this.parents()).reverse();
  this.hooks(name, suites, fn);
};

/**
 * Run hooks from the bottom up.
 *
 * @param {String} name
 * @param {Function} fn
 * @api private
 */

Runner.prototype.hookDown = function(name, fn){
  var suites = [this.suite].concat(this.parents());
  this.hooks(name, suites, fn);
};

/**
 * Return an array of parent Suites from
 * closest to furthest.
 *
 * @return {Array}
 * @api private
 */

Runner.prototype.parents = function(){
  var suite = this.suite
    , suites = [];
  while (suite = suite.parent) suites.push(suite);
  return suites;
};

/**
 * Run the current test and callback `fn(err)`.
 *
 * @param {Function} fn
 * @api private
 */

Runner.prototype.runTest = function(fn){
  var test = this.test
    , self = this;

  if (this.asyncOnly) test.asyncOnly = true;

  try {
    test.on(&#039;error&#039;, function(err){
      self.fail(test, err);
    });
    test.run(fn);
  } catch (err) {
    fn(err);
  }
};

/**
 * Run tests in the given `suite` and invoke
 * the callback `fn()` when complete.
 *
 * @param {Suite} suite
 * @param {Function} fn
 * @api private
 */

Runner.prototype.runTests = function(suite, fn){
  var self = this
    , tests = suite.tests.slice()
    , test;


  function hookErr(err, errSuite, after) {
    // before/after Each hook for errSuite failed:
    var orig = self.suite;

    // for failed &#039;after each&#039; hook start from errSuite parent,
    // otherwise start from errSuite itself
    self.suite = after ? errSuite.parent : errSuite;

    if (self.suite) {
      // call hookUp afterEach
      self.hookUp(&#039;afterEach&#039;, function(err2, errSuite2) {
        self.suite = orig;
        // some hooks may fail even now
        if (err2) return hookErr(err2, errSuite2, true);
        // report error suite
        fn(errSuite);
      });
    } else {
      // there is no need calling other &#039;after each&#039; hooks
      self.suite = orig;
      fn(errSuite);
    }
  }

  function next(err, errSuite) {
    // if we bail after first err
    if (self.failures &amp;&amp; suite._bail) return fn();

    if (self._abort) return fn();

    if (err) return hookErr(err, errSuite, true);

    // next test
    test = tests.shift();

    // all done
    if (!test) return fn();

    // grep
    var match = self._grep.test(test.fullTitle());
    if (self._invert) match = !match;
    if (!match) return next();

    // pending
    if (test.pending) {
      self.emit(&#039;pending&#039;, test);
      self.emit(&#039;test end&#039;, test);
      return next();
    }

    // execute test and hook(s)
    self.emit(&#039;test&#039;, self.test = test);
    self.hookDown(&#039;beforeEach&#039;, function(err, errSuite){

      if (err) return hookErr(err, errSuite, false);

      self.currentRunnable = self.test;
      self.runTest(function(err){
        test = self.test;

        if (err) {
          self.fail(test, err);
          self.emit(&#039;test end&#039;, test);
          return self.hookUp(&#039;afterEach&#039;, next);
        }

        test.state = &#039;passed&#039;;
        self.emit(&#039;pass&#039;, test);
        self.emit(&#039;test end&#039;, test);
        self.hookUp(&#039;afterEach&#039;, next);
      });
    });
  }

  this.next = next;
  next();
};

/**
 * Run the given `suite` and invoke the
 * callback `fn()` when complete.
 *
 * @param {Suite} suite
 * @param {Function} fn
 * @api private
 */

Runner.prototype.runSuite = function(suite, fn){
  var total = this.grepTotal(suite)
    , self = this
    , i = 0;

  debug(&#039;run suite %s&#039;, suite.fullTitle());

  if (!total) return fn();

  this.emit(&#039;suite&#039;, this.suite = suite);

  function next(errSuite) {
    if (errSuite) {
      // current suite failed on a hook from errSuite
      if (errSuite == suite) {
        // if errSuite is current suite
        // continue to the next sibling suite
        return done();
      } else {
        // errSuite is among the parents of current suite
        // stop execution of errSuite and all sub-suites
        return done(errSuite);
      }
    }

    if (self._abort) return done();

    var curr = suite.suites[i++];
    if (!curr) return done();
    self.runSuite(curr, next);
  }

  function done(errSuite) {
    self.suite = suite;
    self.hook(&#039;afterAll&#039;, function(){
      self.emit(&#039;suite end&#039;, suite);
      fn(errSuite);
    });
  }

  this.hook(&#039;beforeAll&#039;, function(err){
    if (err) return done();
    self.runTests(suite, next);
  });
};

/**
 * Handle uncaught exceptions.
 *
 * @param {Error} err
 * @api private
 */

Runner.prototype.uncaught = function(err){
  debug(&#039;uncaught exception %s&#039;, err.message);
  var runnable = this.currentRunnable;
  if (!runnable || &#039;failed&#039; == runnable.state) return;
  runnable.clearTimeout();
  err.uncaught = true;
  this.fail(runnable, err);

  // recover from test
  if (&#039;test&#039; == runnable.type) {
    this.emit(&#039;test end&#039;, runnable);
    this.hookUp(&#039;afterEach&#039;, this.next);
    return;
  }

  // bail on hooks
  this.emit(&#039;end&#039;);
};

/**
 * Run the root suite and invoke `fn(failures)`
 * on completion.
 *
 * @param {Function} fn
 * @return {Runner} for chaining
 * @api public
 */

Runner.prototype.run = function(fn){
  var self = this
    , fn = fn || function(){};

  function uncaught(err){
    self.uncaught(err);
  }

  debug(&#039;start&#039;);

  // callback
  this.on(&#039;end&#039;, function(){
    debug(&#039;end&#039;);
    process.removeListener(&#039;uncaughtException&#039;, uncaught);
    fn(self.failures);
  });

  // run suites
  this.emit(&#039;start&#039;);
  this.runSuite(this.suite, function(){
    debug(&#039;finished running&#039;);
    self.emit(&#039;end&#039;);
  });

  // uncaught exception
  process.on(&#039;uncaughtException&#039;, uncaught);

  return this;
};

/**
 * Cleanly abort execution
 *
 * @return {Runner} for chaining
 * @api public
 */
Runner.prototype.abort = function(){
  debug(&#039;aborting&#039;);
  this._abort = true;
}

/**
 * Filter leaks with the given globals flagged as `ok`.
 *
 * @param {Array} ok
 * @param {Array} globals
 * @return {Array}
 * @api private
 */

function filterLeaks(ok, globals) {
  return filter(globals, function(key){
    // Firefox and Chrome exposes iframes as index inside the window object
    if (/^d+/.test(key)) return false;

    // in firefox
    // if runner runs in an iframe, this iframe&#039;s window.getInterface method not init at first
    // it is assigned in some seconds
    if (global.navigator &amp;&amp; /^getInterface/.test(key)) return false;

    // an iframe could be approached by window[iframeIndex]
    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
    if (global.navigator &amp;&amp; /^\d+/.test(key)) return false;

    // Opera and IE expose global variables for HTML element IDs (issue #243)
    if (/^mocha-/.test(key)) return false;

    var matched = filter(ok, function(ok){
      if (~ok.indexOf(&#039;*&#039;)) return 0 == key.indexOf(ok.split(&#039;*&#039;)[0]);
      return key == ok;
    });
    return matched.length == 0 &amp;&amp; (!global.navigator || &#039;onerror&#039; !== key);
  });
}

/**
 * Array of globals dependent on the environment.
 *
 * @return {Array}
 * @api private
 */

 function extraGlobals() {
  if (typeof(process) === &#039;object&#039; &amp;&amp;
      typeof(process.version) === &#039;string&#039;) {

    var nodeVersion = process.version.split(&#039;.&#039;).reduce(function(a, v) {
      return a &lt;&lt; 8 | v;
    });

    // &#039;errno&#039; was renamed to process._errno in v0.9.11.

    if (nodeVersion &lt; 0x00090B) {
      return [&#039;errno&#039;];
    }
  }

  return [];
 }

}); // module: runner.js

require.register(&quot;suite.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var EventEmitter = require(&#039;browser/events&#039;).EventEmitter
  , debug = require(&#039;browser/debug&#039;)(&#039;mocha:suite&#039;)
  , milliseconds = require(&#039;./ms&#039;)
  , utils = require(&#039;./utils&#039;)
  , Hook = require(&#039;./hook&#039;);

/**
 * Expose `Suite`.
 */

exports = module.exports = Suite;

/**
 * Create a new `Suite` with the given `title`
 * and parent `Suite`. When a suite with the
 * same title is already present, that suite
 * is returned to provide nicer reporter
 * and more flexible meta-testing.
 *
 * @param {Suite} parent
 * @param {String} title
 * @return {Suite}
 * @api public
 */

exports.create = function(parent, title){
  var suite = new Suite(title, parent.ctx);
  suite.parent = parent;
  if (parent.pending) suite.pending = true;
  title = suite.fullTitle();
  parent.addSuite(suite);
  return suite;
};

/**
 * Initialize a new `Suite` with the given
 * `title` and `ctx`.
 *
 * @param {String} title
 * @param {Context} ctx
 * @api private
 */

function Suite(title, ctx) {
  this.title = title;
  this.ctx = ctx;
  this.suites = [];
  this.tests = [];
  this.pending = false;
  this._beforeEach = [];
  this._beforeAll = [];
  this._afterEach = [];
  this._afterAll = [];
  this.root = !title;
  this._timeout = 2000;
  this._slow = 75;
  this._bail = false;
}

/**
 * Inherit from `EventEmitter.prototype`.
 */

function F(){};
F.prototype = EventEmitter.prototype;
Suite.prototype = new F;
Suite.prototype.constructor = Suite;


/**
 * Return a clone of this `Suite`.
 *
 * @return {Suite}
 * @api private
 */

Suite.prototype.clone = function(){
  var suite = new Suite(this.title);
  debug(&#039;clone&#039;);
  suite.ctx = this.ctx;
  suite.timeout(this.timeout());
  suite.slow(this.slow());
  suite.bail(this.bail());
  return suite;
};

/**
 * Set timeout `ms` or short-hand such as &quot;2s&quot;.
 *
 * @param {Number|String} ms
 * @return {Suite|Number} for chaining
 * @api private
 */

Suite.prototype.timeout = function(ms){
  if (0 == arguments.length) return this._timeout;
  if (&#039;string&#039; == typeof ms) ms = milliseconds(ms);
  debug(&#039;timeout %d&#039;, ms);
  this._timeout = parseInt(ms, 10);
  return this;
};

/**
 * Set slow `ms` or short-hand such as &quot;2s&quot;.
 *
 * @param {Number|String} ms
 * @return {Suite|Number} for chaining
 * @api private
 */

Suite.prototype.slow = function(ms){
  if (0 === arguments.length) return this._slow;
  if (&#039;string&#039; == typeof ms) ms = milliseconds(ms);
  debug(&#039;slow %d&#039;, ms);
  this._slow = ms;
  return this;
};

/**
 * Sets whether to bail after first error.
 *
 * @parma {Boolean} bail
 * @return {Suite|Number} for chaining
 * @api private
 */

Suite.prototype.bail = function(bail){
  if (0 == arguments.length) return this._bail;
  debug(&#039;bail %s&#039;, bail);
  this._bail = bail;
  return this;
};

/**
 * Run `fn(test[, done])` before running tests.
 *
 * @param {Function} fn
 * @return {Suite} for chaining
 * @api private
 */

Suite.prototype.beforeAll = function(title, fn){
  if (this.pending) return this;
  if (&#039;function&#039; === typeof title) {
    fn = title;
    title = fn.name;
  }
  title = &#039;&quot;before all&quot; hook&#039; + (title ? &#039;: &#039; + title : &#039;&#039;);

  var hook = new Hook(title, fn);
  hook.parent = this;
  hook.timeout(this.timeout());
  hook.slow(this.slow());
  hook.ctx = this.ctx;
  this._beforeAll.push(hook);
  this.emit(&#039;beforeAll&#039;, hook);
  return this;
};

/**
 * Run `fn(test[, done])` after running tests.
 *
 * @param {Function} fn
 * @return {Suite} for chaining
 * @api private
 */

Suite.prototype.afterAll = function(title, fn){
  if (this.pending) return this;
  if (&#039;function&#039; === typeof title) {
    fn = title;
    title = fn.name;
  }
  title = &#039;&quot;after all&quot; hook&#039; + (title ? &#039;: &#039; + title : &#039;&#039;);

  var hook = new Hook(title, fn);
  hook.parent = this;
  hook.timeout(this.timeout());
  hook.slow(this.slow());
  hook.ctx = this.ctx;
  this._afterAll.push(hook);
  this.emit(&#039;afterAll&#039;, hook);
  return this;
};

/**
 * Run `fn(test[, done])` before each test case.
 *
 * @param {Function} fn
 * @return {Suite} for chaining
 * @api private
 */

Suite.prototype.beforeEach = function(title, fn){
  if (this.pending) return this;
  if (&#039;function&#039; === typeof title) {
    fn = title;
    title = fn.name;
  }
  title = &#039;&quot;before each&quot; hook&#039; + (title ? &#039;: &#039; + title : &#039;&#039;);

  var hook = new Hook(title, fn);
  hook.parent = this;
  hook.timeout(this.timeout());
  hook.slow(this.slow());
  hook.ctx = this.ctx;
  this._beforeEach.push(hook);
  this.emit(&#039;beforeEach&#039;, hook);
  return this;
};

/**
 * Run `fn(test[, done])` after each test case.
 *
 * @param {Function} fn
 * @return {Suite} for chaining
 * @api private
 */

Suite.prototype.afterEach = function(title, fn){
  if (this.pending) return this;
  if (&#039;function&#039; === typeof title) {
    fn = title;
    title = fn.name;
  }
  title = &#039;&quot;after each&quot; hook&#039; + (title ? &#039;: &#039; + title : &#039;&#039;);

  var hook = new Hook(title, fn);
  hook.parent = this;
  hook.timeout(this.timeout());
  hook.slow(this.slow());
  hook.ctx = this.ctx;
  this._afterEach.push(hook);
  this.emit(&#039;afterEach&#039;, hook);
  return this;
};

/**
 * Add a test `suite`.
 *
 * @param {Suite} suite
 * @return {Suite} for chaining
 * @api private
 */

Suite.prototype.addSuite = function(suite){
  suite.parent = this;
  suite.timeout(this.timeout());
  suite.slow(this.slow());
  suite.bail(this.bail());
  this.suites.push(suite);
  this.emit(&#039;suite&#039;, suite);
  return this;
};

/**
 * Add a `test` to this suite.
 *
 * @param {Test} test
 * @return {Suite} for chaining
 * @api private
 */

Suite.prototype.addTest = function(test){
  test.parent = this;
  test.timeout(this.timeout());
  test.slow(this.slow());
  test.ctx = this.ctx;
  this.tests.push(test);
  this.emit(&#039;test&#039;, test);
  return this;
};

/**
 * Return the full title generated by recursively
 * concatenating the parent&#039;s full title.
 *
 * @return {String}
 * @api public
 */

Suite.prototype.fullTitle = function(){
  if (this.parent) {
    var full = this.parent.fullTitle();
    if (full) return full + &#039; &#039; + this.title;
  }
  return this.title;
};

/**
 * Return the total number of tests.
 *
 * @return {Number}
 * @api public
 */

Suite.prototype.total = function(){
  return utils.reduce(this.suites, function(sum, suite){
    return sum + suite.total();
  }, 0) + this.tests.length;
};

/**
 * Iterates through each suite recursively to find
 * all tests. Applies a function in the format
 * `fn(test)`.
 *
 * @param {Function} fn
 * @return {Suite}
 * @api private
 */

Suite.prototype.eachTest = function(fn){
  utils.forEach(this.tests, fn);
  utils.forEach(this.suites, function(suite){
    suite.eachTest(fn);
  });
  return this;
};

}); // module: suite.js

require.register(&quot;test.js&quot;, function(module, exports, require){

/**
 * Module dependencies.
 */

var Runnable = require(&#039;./runnable&#039;);

/**
 * Expose `Test`.
 */

module.exports = Test;

/**
 * Initialize a new `Test` with the given `title` and callback `fn`.
 *
 * @param {String} title
 * @param {Function} fn
 * @api private
 */

function Test(title, fn) {
  Runnable.call(this, title, fn);
  this.pending = !fn;
  this.type = &#039;test&#039;;
}

/**
 * Inherit from `Runnable.prototype`.
 */

function F(){};
F.prototype = Runnable.prototype;
Test.prototype = new F;
Test.prototype.constructor = Test;


}); // module: test.js

require.register(&quot;utils.js&quot;, function(module, exports, require){
/**
 * Module dependencies.
 */

var fs = require(&#039;browser/fs&#039;)
  , path = require(&#039;browser/path&#039;)
  , join = path.join
  , debug = require(&#039;browser/debug&#039;)(&#039;mocha:watch&#039;);

/**
 * Ignored directories.
 */

var ignore = [&#039;node_modules&#039;, &#039;.git&#039;];

/**
 * Escape special characters in the given string of html.
 *
 * @param  {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html){
  return String(html)
    .replace(/&amp;/g, &#039;&amp;amp;&#039;)
    .replace(/&quot;/g, &#039;&amp;quot;&#039;)
    .replace(/&lt;/g, &#039;&amp;lt;&#039;)
    .replace(/&gt;/g, &#039;&amp;gt;&#039;);
};

/**
 * Array#forEach (&lt;=IE8)
 *
 * @param {Array} array
 * @param {Function} fn
 * @param {Object} scope
 * @api private
 */

exports.forEach = function(arr, fn, scope){
  for (var i = 0, l = arr.length; i &lt; l; i++)
    fn.call(scope, arr[i], i);
};

/**
 * Array#map (&lt;=IE8)
 *
 * @param {Array} array
 * @param {Function} fn
 * @param {Object} scope
 * @api private
 */

exports.map = function(arr, fn, scope){
  var result = [];
  for (var i = 0, l = arr.length; i &lt; l; i++)
    result.push(fn.call(scope, arr[i], i));
  return result;
};

/**
 * Array#indexOf (&lt;=IE8)
 *
 * @parma {Array} arr
 * @param {Object} obj to find index of
 * @param {Number} start
 * @api private
 */

exports.indexOf = function(arr, obj, start){
  for (var i = start || 0, l = arr.length; i &lt; l; i++) {
    if (arr[i] === obj)
      return i;
  }
  return -1;
};

/**
 * Array#reduce (&lt;=IE8)
 *
 * @param {Array} array
 * @param {Function} fn
 * @param {Object} initial value
 * @api private
 */

exports.reduce = function(arr, fn, val){
  var rval = val;

  for (var i = 0, l = arr.length; i &lt; l; i++) {
    rval = fn(rval, arr[i], i, arr);
  }

  return rval;
};

/**
 * Array#filter (&lt;=IE8)
 *
 * @param {Array} array
 * @param {Function} fn
 * @api private
 */

exports.filter = function(arr, fn){
  var ret = [];

  for (var i = 0, l = arr.length; i &lt; l; i++) {
    var val = arr[i];
    if (fn(val, i, arr)) ret.push(val);
  }

  return ret;
};

/**
 * Object.keys (&lt;=IE8)
 *
 * @param {Object} obj
 * @return {Array} keys
 * @api private
 */

exports.keys = Object.keys || function(obj) {
  var keys = []
    , has = Object.prototype.hasOwnProperty // for `window` on &lt;=IE8

  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }

  return keys;
};

/**
 * Watch the given `files` for changes
 * and invoke `fn(file)` on modification.
 *
 * @param {Array} files
 * @param {Function} fn
 * @api private
 */

exports.watch = function(files, fn){
  var options = { interval: 100 };
  files.forEach(function(file){
    debug(&#039;file %s&#039;, file);
    fs.watchFile(file, options, function(curr, prev){
      if (prev.mtime &lt; curr.mtime) fn(file);
    });
  });
};

/**
 * Ignored files.
 */

function ignored(path){
  return !~ignore.indexOf(path);
}

/**
 * Lookup files in the given `dir`.
 *
 * @return {Array}
 * @api private
 */

exports.files = function(dir, ret){
  ret = ret || [];

  fs.readdirSync(dir)
  .filter(ignored)
  .forEach(function(path){
    path = join(dir, path);
    if (fs.statSync(path).isDirectory()) {
      exports.files(path, ret);
    } else if (path.match(/\.(js|coffee|litcoffee|coffee.md)$/)) {
      ret.push(path);
    }
  });

  return ret;
};

/**
 * Compute a slug from the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.slug = function(str){
  return str
    .toLowerCase()
    .replace(/ +/g, &#039;-&#039;)
    .replace(/[^-\w]/g, &#039;&#039;);
};

/**
 * Strip the function definition from `str`,
 * and re-indent for pre whitespace.
 */

exports.clean = function(str) {
  str = str
    .replace(/\r\n?|[\n\u2028\u2029]/g, &quot;\n&quot;).replace(/^\uFEFF/, &#039;&#039;)
    .replace(/^function *\(.*\) *{/, &#039;&#039;)
    .replace(/\s+\}$/, &#039;&#039;);

  var spaces = str.match(/^\n?( *)/)[1].length
    , tabs = str.match(/^\n?(\t*)/)[1].length
    , re = new RegExp(&#039;^\n?&#039; + (tabs ? &#039;\t&#039; : &#039; &#039;) + &#039;{&#039; + (tabs ? tabs : spaces) + &#039;}&#039;, &#039;gm&#039;);

  str = str.replace(re, &#039;&#039;);

  return exports.trim(str);
};

/**
 * Escape regular expression characters in `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.escapeRegexp = function(str){
  return str.replace(/[-\\^$*+?.()|[\]{}]/g, &quot;\\$&amp;&quot;);
};

/**
 * Trim the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.trim = function(str){
  return str.replace(/^\s+|\s+$/g, &#039;&#039;);
};

/**
 * Parse the given `qs`.
 *
 * @param {String} qs
 * @return {Object}
 * @api private
 */

exports.parseQuery = function(qs){
  return exports.reduce(qs.replace(&#039;?&#039;, &#039;&#039;).split(&#039;&amp;&#039;), function(obj, pair){
    var i = pair.indexOf(&#039;=&#039;)
      , key = pair.slice(0, i)
      , val = pair.slice(++i);

    obj[key] = decodeURIComponent(val);
    return obj;
  }, {});
};

/**
 * Highlight the given string of `js`.
 *
 * @param {String} js
 * @return {String}
 * @api private
 */

function highlight(js) {
  return js
    .replace(/&lt;/g, &#039;&amp;lt;&#039;)
    .replace(/&gt;/g, &#039;&amp;gt;&#039;)
    .replace(/\/\/(.*)/gm, &#039;&lt;span class=&quot;comment&quot;&gt;//$1&lt;/span&gt;&#039;)
    .replace(/(&#039;.*?&#039;)/gm, &#039;&lt;span class=&quot;string&quot;&gt;$1&lt;/span&gt;&#039;)
    .replace(/(\d+\.\d+)/gm, &#039;&lt;span class=&quot;number&quot;&gt;$1&lt;/span&gt;&#039;)
    .replace(/(\d+)/gm, &#039;&lt;span class=&quot;number&quot;&gt;$1&lt;/span&gt;&#039;)
    .replace(/\bnew *(\w+)/gm, &#039;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;init&quot;&gt;$1&lt;/span&gt;&#039;)
    .replace(/\b(function|new|throw|return|var|if|else)\b/gm, &#039;&lt;span class=&quot;keyword&quot;&gt;$1&lt;/span&gt;&#039;)
}

/**
 * Highlight the contents of tag `name`.
 *
 * @param {String} name
 * @api private
 */

exports.highlightTags = function(name) {
  var code = document.getElementsByTagName(name);
  for (var i = 0, len = code.length; i &lt; len; ++i) {
    code[i].innerHTML = highlight(code[i].innerHTML);
  }
};

}); // module: utils.js
// The global object is &quot;self&quot; in Web Workers.
global = (function() { return this; })();

/**
 * Save timer references to avoid Sinon interfering (see GH-237).
 */

var Date = global.Date;
var setTimeout = global.setTimeout;
var setInterval = global.setInterval;
var clearTimeout = global.clearTimeout;
var clearInterval = global.clearInterval;

/**
 * Node shims.
 *
 * These are meant only to allow
 * mocha.js to run untouched, not
 * to allow running node code in
 * the browser.
 */

var process = {};
process.exit = function(status){};
process.stdout = {};

var uncaughtExceptionHandlers = [];

/**
 * Remove uncaughtException listener.
 */

process.removeListener = function(e, fn){
  if (&#039;uncaughtException&#039; == e) {
    global.onerror = function() {};
    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);
    if (i != -1) { uncaughtExceptionHandlers.splice(i, 1); }
  }
};

/**
 * Implements uncaughtException listener.
 */

process.on = function(e, fn){
  if (&#039;uncaughtException&#039; == e) {
    global.onerror = function(err, url, line){
      fn(new Error(err + &#039; (&#039; + url + &#039;:&#039; + line + &#039;)&#039;));
      return true;
    };
    uncaughtExceptionHandlers.push(fn);
  }
};

/**
 * Expose mocha.
 */

var Mocha = global.Mocha = require(&#039;mocha&#039;),
    mocha = global.mocha = new Mocha({ reporter: &#039;html&#039; });

// The BDD UI is registered by default, but no UI will be functional in the
// browser without an explicit call to the overridden `mocha.ui` (see below).
// Ensure that this default UI does not expose its methods to the global scope.
mocha.suite.removeAllListeners(&#039;pre-require&#039;);

var immediateQueue = []
  , immediateTimeout;

function timeslice() {
  var immediateStart = new Date().getTime();
  while (immediateQueue.length &amp;&amp; (new Date().getTime() - immediateStart) &lt; 100) {
    immediateQueue.shift()();
  }
  if (immediateQueue.length) {
    immediateTimeout = setTimeout(timeslice, 0);
  } else {
    immediateTimeout = null;
  }
}

/**
 * High-performance override of Runner.immediately.
 */

Mocha.Runner.immediately = function(callback) {
  immediateQueue.push(callback);
  if (!immediateTimeout) {
    immediateTimeout = setTimeout(timeslice, 0);
  }
};

/**
 * Function to allow assertion libraries to throw errors directly into mocha.
 * This is useful when running tests in a browser because window.onerror will
 * only receive the &#039;message&#039; attribute of the Error.
 */
mocha.throwError = function(err) {
  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {
    fn(err);
  });
  throw err;
};

/**
 * Override ui to ensure that the ui functions are initialized.
 * Normally this would happen in Mocha.prototype.loadFiles.
 */

mocha.ui = function(ui){
  Mocha.prototype.ui.call(this, ui);
  this.suite.emit(&#039;pre-require&#039;, global, null, this);
  return this;
};

/**
 * Setup mocha with the given setting options.
 */

mocha.setup = function(opts){
  if (&#039;string&#039; == typeof opts) opts = { ui: opts };
  for (var opt in opts) this[opt](opts[opt]);
  return this;
};

/**
 * Run mocha, returning the Runner.
 */

mocha.run = function(fn){
  var options = mocha.options;
  mocha.globals(&#039;location&#039;);

  var query = Mocha.utils.parseQuery(global.location.search || &#039;&#039;);
  if (query.grep) mocha.grep(query.grep);
  if (query.invert) mocha.invert();

  return Mocha.prototype.run.call(mocha, function(){
    // The DOM Document is not available in Web Workers.
    if (global.document) {
      Mocha.utils.highlightTags(&#039;code&#039;);
    }
    if (fn) fn();
  });
};

/**
 * Expose the process shim.
 */

Mocha.process = process;
})();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
