<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - Forwarder.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>Forwarder.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">277</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">51.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.27</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var contrib = require(&quot;ndn-contrib&quot;), ndn = contrib.ndn;

/**Main forwarder for Blanc
 *@constructor
 *@returns {forwarder} an NDN Subject
 *
 */
var Forwarder = function Forwarder (){
  this.nameTree = new contrib.NameTree();
  this.fib = new contrib.FIB(this.nameTree);
  this.listeners = new contrib.FIB(new contrib.NameTree());
  this.pit = new contrib.PIT(this.nameTree);
  this.cache = new contrib.ContentStore(this.nameTree);
  this.interfaces = new contrib.Interfaces(this);

  var transports = Object.keys(contrib.Transports);

  for (var i = 0; i &lt; transports.length; i++){
    if (contrib.Transports[transports[i]].defineListener){
      contrib.Transports[transports[i]].defineListener(this);
    }
    this.interfaces.installTransport(contrib.Transports[transports[i]]);
  }

  return this;
};

/**handle an incoming interest from the interfaces module
 *@param {Buffer} element the raw interest packet
 *@param {Number} faceID the Integer faceID of the face which recieved the Interest
 *@returns {this} for chaining
 */
Forwarder.prototype.handleInterest = function(element, faceID){
  var override = {}
    , Self = this
    , interest = new ndn.Interest();

  console.log(&quot;problem/?&quot;);
  interest.wireDecode(element);
  console.log(&quot;decode&quot;);

  function Closure(skipListen, skipForward, listeners){
    console.log(&quot;closure start&quot;, listeners, interest.name.toUri());
    listeners = listeners || Self.listeners.findAllFibEntries(interest.name);
    console.log(&quot;listeners: &quot;, listeners);

    function unblock(){
      var Self = this;
      return function unblock(skipListen){
        console.log(Self);
        Closure(skipListen, false, listeners);
      };
    }

    function iterateListeners(){
      if (listeners.hasNext){
        var listener = listeners.next();
        console.log(&quot;iterate listeners, current =&quot;, listener.nextHops);
        var blockingCallback;

        for (var i = 0; i &lt; listener.nextHops.length; i++){
          console.log(listener.nextHops[i]);
          if (Self.listenerCallbacks[listener.nextHops[i].faceID].blocking){

            blockingCallback = Self.listenerCallbacks[listener.nextHops[i].faceID].callback;
            block = true;
          } else {
            Self.listenerCallbacks[listener.nextHops[i].faceID].callback(interest, faceID);
          }
        }
        console.log(&quot;blocking&quot;, block, blockingCallback);
        if (blockingCallback){
          blockingCallback(interest, faceID, new unblock());
        } else if (listeners.hasNext) {
          iterateListeners();
        } else {
          forward();
        }
      } else {
        forward();
      }
    }

    if (!skipListen){
      iterateListeners();
    }

    function forward(){
      console.log(&quot;not skipping forward&quot;);
      var cacheHit = Self.cache.check(interest);

      if (cacheHit){
        Self.interfaces.dispatch(cacheHit, 0 | (1&lt;&lt;faceID));
      } else if (!override.skipForward){
        var nextHopFlag = Self.fib.findAllNextHops(interest.name, faceID);
        if (nextHopFlag){
          Self.pit.insertPitEntry(element, interest, faceID);
          Self.interfaces.dispatch(element, nextHopFlag);
        }
      }
    }
    console.log(&quot;returning from CLosure&quot;);
    return Self;
  }




  return Closure();
};

/** main algorithm for incoming data packets
 *@param {Buffer} element the raw data packet
 *@param {faceID} the numerical faceID that the packet arrived on
 *@returns {Forwarder} for chaining
 */
Forwarder.prototype.handleData = function(element, faceID){
  var data = new ndn.Data();
  data.wireDecode(element);

  var pitMatch = this.pit.lookup(data);

  if (pitMatch.faces){
    console.log(pitMatch);
    this.cache.insert(element, data);
    for (var i = 0; i &lt; pitMatch.pitEntries.length; i++){
      pitMatch.pitEntries[i].consume();
    }
    this.interfaces.dispatch(element, pitMatch.faces);

  }
  return this;
};


/** add a nameSpace Listener to the Forwarder. the listener will be triggered via the same semantics as forwarding entries
 *@param {String | option} nameSpace the uri of the namespace to listen on, or an options object containing that uri under the .prefix property
 *so far only a boolean &#039;.blocking&#039; property, to tell whether to interupt normal forwarding
 *@param {function} callback
 */
Forwarder.prototype.addListener = function(nameSpace, callback) {
  this.listenerCallbacks = this.listenerCallbacks || [];
  var prefix
    , options
    , Self = this;

  if (typeof nameSpace === &quot;string&quot;){
    prefix = nameSpace;
    options = {};
  } else {
    prefix = nameSpace.prefix;
    options = nameSpace;
  }

  prefix = new ndn.Name(prefix);
  prefix = prefix.toUri();

  var listenerID = this.listenerCallbacks.length
    , isNew = true;


  if(options.blocking){
    var blockingReplaced = false;

    if (this.listenerCallbacks.length &gt; 0){
      for (var i = 0; i &lt; this.listenerCallbacks.length; i++){
        console.log(&quot;loop&quot;, i, prefix, this.listenerCallbacks[i]);
        if (this.listenerCallbacks[i].prefix === prefix){
          this.listenerCallbacks[i].callback = callback;
          blockingReplaced = true;
          isNew = false;
          console.log(&quot;found&quot;);
          break;
        }
      }
    }

    if (!blockingReplaced){
      console.log(&quot;not found&quot;);
      this.listenerCallbacks.push({
        blocking : true
        , callback : callback
        , listenerID : listenerID
        , prefix : prefix
      });
      console.log(&quot;pushed&quot;);
    }
  } else {
    this.listenerCallbacks.push({
      blocking: false
      , callback: callback
      , listenerID: listenerID
      , prefix : prefix
    });
  }

  if (isNew){
    this.listeners.addEntry(prefix, listenerID);
  }

  return this;
};

/** Remove ALL listeners on a given namespace (but NOT all prefixes) ie, two listeners on /a/b and one on /a: .removeListeners(&quot;/a/b&quot;) will remove both on /a/b and leave the one on /a
 *@param {String} prefix the nameSpace uri to remove listeners on
 *@returns {this} for chaining
 */
Forwarder.prototype.removeListeners = function(prefix){
  prefix = new ndn.Name(prefix);

  this.listenerCallbacks = this.listenerCallbacks || [];
  if (this.listenerCallbacks.length === 0){
    return this;
  }

  var listenerEntry = this.listeners.lookup(prefix);

  while(listenerEntry.nextHops.length){
    var hopEntry = listenerEntry.nextHops.pop();

    this.listenerCallbacks[hopEntry.faceID].callback = null;
  }

  return this;
};

/** set maximum number of connections for the forwarder (default unset)
 *@param {Number} maximum the maximum number of simultaneous connections
 *@returns {this} for chaining
 */
Forwarder.prototype.setMaxConnections = function(maximum){
  this.maxConnections = maximum;
  return this;
};

/** add a connection
 *@param {String} protocol the .name property of the underlying protocol
 *@param {Object} parameters the necessary parameters for the connection
 *@param {function} callback function recieves the numerical faceID of the new face
 */
Forwarder.prototype.addConnection = function(protocol, parameters, callback){
  this.connectionCount = this.connectionCount || 0;
  if (this.interfaces.Faces.length &lt; this.maxConnections){
    this.connectionCount++;
    callback(this.interfaces.newFace(protocol, parameters));
  } else {
    console.log(&quot;maximum connections reached&quot;);
  }

  return this;
};


/** remove a connection, and purge any registered Prefixes from the FIB
 *@param {Number} faceID Numerical faceID of the connection to remove
 *@returns {this} Forwarder for chaining
 *
 */
Forwarder.prototype.removeConnection = function(faceID) {
  while ( this.interfaces.Faces[faceID].prefixes.length &gt; 0){
    this.fib
    .lookup(this.interfaces.Faces[faceID].prefixes.pop())
    .removeNextHop({
      faceID: faceID
    });
  }

  this.interfaces.Faces[faceID].close();

  return this;
};

Forwarder.prototype.requestConnection = function(prefix){

};

module.exports = Forwarder;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
