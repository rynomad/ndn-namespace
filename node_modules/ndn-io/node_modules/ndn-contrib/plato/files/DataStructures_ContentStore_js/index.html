<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - DataStructures/ContentStore.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>DataStructures/ContentStore.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">198</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">69.84</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.99</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var debug = false;

function pubKeyMatch (ar1, ar2){
  if (!ar1){
    return true;
  }
  for(var i = 0; i &lt; ar1.length; i++ ){
    if (ar1[i] !== ar2[i]){
      return false;
    }
  }
  return true;
}


/** Default EntryClass for ContentStore
 *@constructor
 *@private
 *@param {Buffer} element the raw data packet.
 *@param {Data} data the ndn.Data object
 */
function csEntry (element, data){
  var freshnessPeriod = data.getMetaInfo().getFreshnessPeriod();
  this.name = data.name;
  this.element = element;
  this.freshnessPeriod = freshnessPeriod;
  this.uri = data.name.toUri();
  this.publisherPublicKeyDigest = data.signedInfo.publisher.publisherPublicKeyDigest;
  return this;
}

/**
 *@property {String} type a type string describing the type of entry
 */
csEntry.type = &quot;csEntry&quot;;

/** sync/async getter for the element
 *@private
 *@param {function} callback Recieves element as only argument
 *@returns {Buffer} element the raw data packet
 */
csEntry.prototype.getElement = function(callback){
  callback = callback || function(e){return e;};
  return callback(this.element);
};

/**
 *@private
 *@param {NameTreeNode} node the node to remove this entry from
 *@returns {csEntry} entry the csEntry in case you want to do something other than throw it away
 */
csEntry.prototype.stale = function(node){
  delete node.csEntry;
  return this;
};

/**A ContentStore constructor for building cache&#039;s and database indexes
 *@constructor
 *@param {NameTree} nameTree the nameTree to build upon
 *@param {constructor} entryClass a constructor class conforming to the same API as {@link csEntry}.
 *@returns {ContentStore} - a new store
 */
var ContentStore = function ContentStore(nameTree, entryClass){
  this.nameTree = nameTree;
  this.EntryClass = entryClass || csEntry;
  return this;
};

/**check the ContentStore for data matching a given interest (including min/max suffix, exclude, publisherKey)
 *@param {ndn.Interest} interest the interest to match against
 *@param {function=} callback for asynchronous cases (like levelDB). recieves return value as only argument
 *@returns {Buffer | null}
 */
ContentStore.prototype.check = function(interest, callback, node, suffixCount, childTracker, stack){
  callback = callback || function(element){return element;};
  node = node || this.nameTree.lookup(interest.name);
  stack = stack || 1;
  stack++;
  if (stack++ &gt; Object.keys(this.nameTree).length * 2){
    console.log(&quot;stack over&quot;);
    return callback(null);
  }

  var self = this;

  if (node[this.EntryClass.type]
      &amp;&amp; interest.matchesName(node[this.EntryClass.type].name)
      &amp;&amp; pubKeyMatch(interest.publisherPublicKeyDigest, node[this.EntryClass.type].publisherPublicKeyDigest)
     ){
    return node[this.EntryClass.type].getElement(callback);
  }



  suffixCount = suffixCount || 0;
  childTracker = childTracker || [];

  var maxSuffix = interest.getMaxSuffixComponents()
    , minSuffix = interest.getMinSuffixComponents()
    , childSelector = interest.getChildSelector()
    , atMaxSuffix = (maxSuffix &amp;&amp; (suffixCount === maxSuffix))
    , hasChildren = (node.children.length &gt; 0)
    , hasMoreSiblings = function(node){
      if (debug) {console.log(childTracker.length, node.parent.children.length, childTracker[childTracker.length - 1] );}
      return  (!!childTracker.length &amp;&amp; !!node.parent &amp;&amp; (node.parent.children.length &gt; childTracker[childTracker.length - 1] + 1));
    };

  if (debug) {console.log(node.prefix.toUri(), interest.name.toUri(), childTracker, hasMoreSiblings(node));}

  function toChild(node){
    if (debug) {console.log(&quot;toChild&quot;, childTracker);}
    suffixCount++;
    childTracker.push(0);
    if (!childSelector){ //leftmost == 0 == falsey

      return self.check(interest, callback, node.children[0], suffixCount, childTracker , stack++);
    } else {

      return self.check(interest, callback, node.children[node.children.length - 1], suffixCount, childTracker, stack++);
    }
  }

  function toSibling(node){
    if (debug) {console.log(&quot;toSibling from &quot;, node.prefix.toUri(), childTracker, node);}
    childTracker[childTracker.length - 1]++;

    if (!childSelector){
      if (debug) {console.log(node.prefix.toUri(), childTracker, node.parent.children[childTracker[childTracker.length - 1]].prefix.toUri());}
      return self.check(interest, callback, node.parent.children[childTracker[childTracker.length - 1]], suffixCount, childTracker, stack++);
    } else {
      if (debug) {console.log(node.prefix.toUri(), childTracker, node.parent.children[node.parent.children.length  + ~childTracker[childTracker.length - 1]].prefix.toUri());}
      return self.check(interest, callback, node.parent.children[node.parent.children.length  + ~childTracker[childTracker.length - 1]], suffixCount, childTracker, stack++);
    }
  }

  function toAncestorSibling(node, stack){
    if (debug) {console.log(&quot;toAncestorSibling from &quot;,node.prefix.toUri(), childTracker);}
    suffixCount--;
    childTracker.pop();
    if (stack++ &gt; 10000){
      return callback(null);
    }

    var hasParentSibling = (node.parent &amp;&amp; node.parent.parent &amp;&amp; node.parent.parent.children.length &gt; childTracker[childTracker.length - 1] + 1);

    if (hasParentSibling){
      return toSibling(node.parent);
    } else if (childTracker.length &gt;0) {
      return toAncestorSibling(node.parent, stack++);
    } else {
      return callback(null);
    }
  }

  if (childTracker.length === 1){
    if (interest.exclude.matches(node.prefix.get(-1))){
      if (hasMoreSiblings(node)){
        return toSibling(node);
      } else {
        return callback(null);
      }
    }
  }



  if (!node.prefix.size() ||(!atMaxSuffix &amp;&amp; hasChildren)){
    return toChild(node);
  } else if (hasMoreSiblings(node)){
    return toSibling(node);
  } else if (childTracker.length &gt; 1){
    return toAncestorSibling(node);
  } else{
    return callback(null);
  }
};

/**Insert a new entry into the contentStore
 *@constructor
 *@param {Buffer} element the raw data packet
 *@param {ndn.Data} data the ndn.Data object
 *@returns {ContentStore} - for chaining
 */
ContentStore.prototype.insert = function(element, data){
  var Entry = this.EntryClass;
  var freshness = data.getMetaInfo().getFreshnessPeriod();
  var node = this.nameTree.lookup(data.name)
  , entry = new Entry(element, data);
  node[Entry.type] = entry;
  node[Entry.type].nameTreeNode = node;
  setTimeout(function(){
    if (node[Entry.type]) {node[Entry.type].stale(node);}
  }, freshness || 20 );
  return this;
};


module.exports = ContentStore;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
